#+title: Source
#+STARTUP: show2levels

* Ideas
The main idea of this project is to have a single, closed source api interface that will be the SINGLE source for starintel data

** allow it to be extended
Using common vars/hooks whatever to establish a config that can be updated as i age this system out when EOL.



* Packaging
** Nix

#+begin_src nix :tangle flake.nix
{
  description = "Starintel API server that routes the data through msg queues.";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }:
    let
      pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in
    {
      devShell.x86_64-linux =
        pkgs.mkShell {
          buildInputs = with pkgs; [
            pkg-config
            sbcl
            openssl
            rabbitmq-c
            libffi
          ];
          shellHook = ''
            export LD_LIBRARY_PATH=${pkgs.lib.makeLibraryPath([pkgs.openssl pkgs.rabbitmq-c pkgs.libffi])}
          '';
        };
    };
}

#+end_src

Here is
#+begin_src sh :tangle .envrc
use flake
# When we run make in prod it will gen defaults
# Debug is just for testing
export BUILD_MODE="DEV"
use flake
export COUCHDB_HOST="127.0.0.1"
export COUCHDB_PORT=5984
export COUCHDB_SCHEME="http"
export COUCHDB_USER="admin"
export COUCHDB_PASSWORD="password"
export COUCHDB_DATABASE="starintel"

#+end_src

#+RESULTS:
: CONTAINER ID   IMAGE                             COMMAND                  CREATED        STATUS      PORTS                                                                                                      NAMES
: d421e7dea3a1   zhaowde/rotating-tor-http-proxy   "/bin/sh -c /start.sh"   3 months ago   Up 8 days   3128/tcp, 0.0.0.0:1444->1444/tcp, :::1444->1444/tcp, 4444/tcp, 0.0.0.0:3128->3218/tcp, :::3128->3218/tcp   docker-rotating-tor-1

** Lisp stuff
*** ASDF
Here is the system def for it.
#+begin_src lisp :tangle source/starintel-gserver.asd

(asdf:defsystem :starintel-gserver
  :version      "0.1.0"
  :description  "hackable/moddable starintel acess api."
  :author       "nsaspy@airmail.cc"
  :license      "GPL v3"
  :components   ((:file "gserver-settings")
                 (:file "package" :depends-on ("gserver-settings"))
                 (:file "actors" :depends-on ("gserver-settings"))
                 (:file "rabbit" :depends-on ("actors" "gserver-settings"))
                 (:file "main" :depends-on ("actors" "rabbit" "package" "gserver-settings")))

  :depends-on   (#:alexandria #:cl-rabbit #:sento #:starintel #:babel #:cl-couch #:cl-json :cl-ulid #:anypool #:cl-cpus))

 #+end_src
*** Namespace setup
I prefer to have my namespace done in a somewhat hierarchical style.

So lets say you want to make a http frontend api, there is going to be the namespace for it:
- star.frontends.http

And a database namespace would be:
- star.database.<database-type-or-name>


#+begin_src lisp :tangle ./source/gserver-settings.lisp :results none
(uiop:define-package   :starintel-settings
  (:nicknames :star.settings)
  (:use :cl)
  (:documentation "settings for the starinte-gserver package")
  (:export
   #:*rabbit-address*
   #:*rabbit-port*
   #:*rabbit-user*
   #:*rabbit-password*))

#+end_src

gserver namespace, general top level.

#+begin_src lisp :tangle ./source/package.lisp
(uiop:define-package   :starintel-gserver
  (:nicknames :star)
  (:use       :cl :cl-rabbit :star.settings)
  (:export
   #:init-db))
#+end_src

#+RESULTS:
: #<PACKAGE "STARINTEL-GSERVER">

#+begin_src lisp :tangle ./source/package.lisp :results none
(uiop:define-package   :starintel-gserver.rabbit
  (:nicknames :star.rabbit)
  (:use       :cl :star.settings)
  (:documentation "Rabitmq namespace"))

#+end_src

** Kali/parrot
#+Name: Install docker
#+begin_src shell :async :results output replace :tangle parrot_kali.sh
install_docker() {
    sudo apt update
    sudo apt install -y apt-transport-https ca-certificates curl software-properties-common
    curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt update
    sudo apt install -y docker-ce docker-ce-cli containerd.io
    sudo apt install -y docker-compose
    sudo usermod -aG docker $USER

}


install_docker

#+end_src

* Settings

** Frontends
*** Http Settings
This section contains only settings related to http frontend

**** Listen Address

#+begin_src lisp :tangle ./source/frontends/settings.lisp
(defparameter *address* "0.0.0.0")
(defparameter *port* 5000)
#+end_src
** Rabbit mq settings
*** Authentication
#+begin_src lisp :tangle ./source/gserver-settings.lisp
(in-package :star.settings)
(defparameter *rabbit-address* "127.0.0.1" "The address rabbitmq is running on.")
(defparameter *rabbit-port* 5672 "The port that rabbitmq is listening on.")
(defparameter *rabbit-user* "guest" "the username for rabbimq")
(defparameter *rabbit-password* "guest" "the password for the rabbitmq user.")
#+end_src

#+RESULTS:
: *RABBIT-PASSWORD*


* Actors
#+property: header-args : tangle: source/actors.lisp  :tangle yes

The sen to package expects us to be in the sento user package.

#+begin_src lisp :tangle ./source/actors.lisp :results none
(in-package :sento-user)
(defparameter *sys* nil "the main actor system")
(defun start-actor-system ()
  (setf *sys* (make-actor-system))
)
 #+end_src

** Eventing

Sento supports events but I can only use a symbol or a simple string. it supports matching by class types too.

This allows actors to filter out messages by topic.

#+begin_src lisp :tangle ./source/actors.lisp :results none
(defclass message-event ()
  ((topic :initarg :topic :initform (error "Topic for event stream is required.") :reader message-topic)
   (data :initarg :data :type string :initform "" :reader message-data))
  (:documentation "A basic class that holds message event topic and data"))
#+end_src

The interface for matching topics is ~topic-match-p~.

#+begin_src lisp :tangle ./source/actors.lisp :results none
(defgeneric topic-match-p (msg topic)
  (:documentation "generic interface that matches if a msg matches the subbed topic."))

(defmethod topic-match-p ((msg message-event) topic)
  "Return T if topic matches msg's topic"
  (string= topic (string-downcase (message-topic msg))))


(defun new-event (&key topic data (eventstream *sys*))
  "Create an publish a new message-event.
    This is a simple wrapper around the publish from sento."
  (publish eventstream (make-instance 'message-event :topic topic :data data)))


(defmacro with-topics ((&key msg topics) &body body)
  "A macro that will check if MSG topic "
  `(loop for topic in ,topics

         if (topic-match-p ,msg topic)
           do (progn ,@body)))
#+end_src

Here is a simple example of an actor that works with person objects.
#+begin_src lisp
(ac:actor-of *sys* :name "personator"
                   :init (lambda (self)
                           (ev:subscribe self self 'message-event))
                   :receive (lambda (msg)
                              (with-topics (:msg msg :topics '("New-Person"))
                                (format nil "~a" (starintel:doc-id msg)))))

#+end_src
** Couchdb

Couchdb is the main database I have used for many projects, I am using [[https://github.com/lost-rob0t/cl-couch][cl-couch]] for the database client. It doesnt use async so I need to setup a resource pools, for that I use anypool.


#+begin_src lisp :tangle ./source/actors.lisp :results none
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") 5984 :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME")))))
                                    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src

start--pool-monitoring is used for checking the total active count from the couchdb client pool.
it is only used internally for debugging.

#+begin_src lisp :tangle ./source/actors.lisp :results none
(defvar *my-thread* nil)

(defun start--pool-monitoring ()
  (setf *my-thread*
        (bt:make-thread
         (lambda ()
           (loop
             do (progn (format t "Active count: ~a, Idle count: ~a~%"
                               (anypool:pool-active-count *couchdb-pool*)
                               (anypool:pool-idle-count *couchdb-pool*))
                       (force-output)
                       (sleep 1))
             finally (bt:thread-yield))))))

(defun stop--pool-monitoring ()
  (when *my-thread*
    (bt:destroy-thread *my-thread*)
    (setf *my-thread* nil)))

#+end_src

*** couchdb-insert actors
This actor will insert documents into couchdb.

#+begin_src lisp :tangle ./source/actors.lisp :results none
(defun start-couchdb-inserts ()
  (defparameter *couchdb-insert* (ac:actor-of *sys*
                                              :name "*couchdb-insert*"
                                              :receive (lambda (msg)
                                                         (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
                                                               (pool *couchdb-pool*))

                                                           (with-context (*sys* :pinned)
                                                             (task-start
                                                              (lambda ()
                                                                (anypool:with-connection (client pool)
                                                                  (cl-couch:create-document client destination-db (cdr msg) :batch "normal"))))))))))
#+end_src

*** TODO finish bulk insert actor

#+begin_src lisp :tangle ./source/actors.lisp :results none
;; (defparameter *couchdb-bulk-insert* (ac:actor-of *sys*
;;                                                  :name "*couchdb-bulk-insert*"
;;                                                  :receive (lambda (msg)
;;                                                             (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
;;                                                                   (pool *couchdb-pool*))
;;                                                               (anypool:with-connection (client pool)
;;                                                                 (cl-couch:bulk-create-documents client destination-db msg :batch "normal"))))))



#+end_src


#+end_src
** TODO Create Target schedualing actor
It will be an actor that kicks off recurring jobs, will require spec change to include "recurring" field.
** actor entry point

#+begin_src lisp :tangle ./source/actors.lisp :results none
(defun start-actors ()
  (start-actor-system)
  (start-couchdb-inserts))
#+end_src

In order to compile the actor system must be stop

* RabbitMQ
The [[https://github.com/lokedhs/cl-rabbit][cl-rabbit]] lib is a bit lower level then I want to work with so I will create a basic macros to make the interface nicer

The newer sento benchmarks are showing its VERY preforment now, so we will actually just create a agent, then use the sento actor system.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(in-package :star.rabbit)

(defmacro with-rabbit-recv ((queue-name exchange-name exchange-type routing-key &key (port *rabbit-port*) (host *rabbit-address*) (username *rabbit-user*) (password *rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)
         (cl-rabbit:exchange-declare conn 1 ,exchange-name ,exchange-type)

         (cl-rabbit:queue-declare conn 1 :queue ,queue-name :durable ,durable :auto-delete ,auto-delete :exclusive ,exclusive)
         (cl-rabbit:queue-bind conn 1 :queue ,queue-name :exchange ,exchange-name :routing-key ,routing-key)
         (cl-rabbit:basic-consume conn 1 ,queue-name)
         ,@body))))

(defmacro with-rabbit-send ((queue-name exchange-name exchange-type routing-key &key (port *rabbit-port*) (host *rabbit-address*) (username *rabbit-user*) (password *rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)

         ,@body))))


#+end_src

Take a rabbimq message and parse it.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun message->string (msg &key (encoding :utf-8))
  "take a rabbitmq message and return the boddy as a string"
  (babel:octets-to-string (cl-rabbit:message/body msg) :encoding encoding))

;TODO
(defun message->object (msg)
  "Tale a rabbbitmq message and return a object. The object that will be returned depends on the message property 'dtype`.")
#+end_src

Start the rabbit new document monitoring thread.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun start-rabbit-document-thread ()
  (bt:make-thread
   (lambda ()
     (with-rabbit-recv ("new-documents" "documents" "topic" "document.new.*")
       (loop
         for msg = (cl-rabbit:consume-message conn)
         for data = (handle-new-document msg)
         do (sento-user::ask *couchdb-insert* data)
         do (sento-user::publish *sys* (new-event :topic (str:title-case (car data) ) :data (cdr data))))))

   :name "*new-documents*"))

#+end_src
** quick test functions

These functions are for quick debugging of the rabbitmq.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun test-make-doc ()

  (with-output-to-string (str) (cl-json:encode-json (starintel:set-meta (make-instance  'starintel:person :id (ulid:ulid) :lname "doe" :fname "john") "starintel") str)))

(defun test-send ()
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket "localhost" 5672)
      (cl-rabbit:login-sasl-plain conn "/" "guest" "guest")
      (cl-rabbit:with-channel (conn 1)
        (cl-rabbit:basic-publish conn 1
                                 :exchange "documents"
                                 :routing-key "new.document.Person"
                                 :body (make-doc)
                                 :properties '((:headers . (("dtype"  . "Person")))))))))

#+end_src

* Databases
** Couchdb
#+begin_src lisp :tangle ./source/init.lisp :results none
(in-package :starintel-gserver)


(defun init-db ()
  "Create the database, and all map-reduce views with it."
  (let* ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") (parse-integer (or (uiop:getenv "COUCHDB_PORT") 5984)) :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME"))))
         (database (or (uiop:getenv "COUCHDB_DATABASE") "starintel")))
    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
    (handler-case (cl-couch:get-database client database)
      (dexador:http-request-not-found () (cl-couch:create-database client database)))))

#+end_src
* Frontends
Frontends  are basicly API services that allow external stuff to tineract with this system.
** asdf

#+begin_src lisp :tangle ./source/frontends/starintel-gserver-frontend.asd
(asdf:defsystem :starintel-gserver-frontend
  :version      "0.1.0"
  :description  "Front end API system(s) for the starintel data system"
  :author       "nsaspy@airmail.cc"
  :serial       t
  :license      "GNU GPL, version 3"
  :components   ((:file "settings")
                 (:file "http"))
  :depends-on   (#:ningle #:clack #:lack :cl-couch))

#+end_src

#+begin_src lisp :tangle ./source/frontends/http.lisp
(uiop:define-package   :star.frontend.http
  (:nicknames :frontend.http)
  (:use       :cl)
  (:documentation "doc"))

#+end_src

** http
#+property: header-args : tangle: source/frontends/.lisp  :tangle yes



*** Database
**** TODO Move this to actors

This is how i create the client
#+begin_src lisp :tangle ./source/frontends/http.lisp

(in-package :star.frontend.http)
(defun init-database (username password &optional (host "127.0.0.1") (port 5984))
  "Add the couchdb object to the context, should only be called once!"
  (let ((client (cl-couch:new-couchdb host port)))
    (cl-couch:password-auth client username password)
    client))

(defun init-state (couchdb)
    "Create the needed databases, map-reduce views. ")
#+end_src

#+RESULTS:
: INIT-DATABASE

I based my couchdb middleware on a gist.[fn:1]
#+begin_src lisp :tangle ./source/frontends/http.lisp
(in-package :star.frontend.http)

(defclass app (ningle:app)
  ()
  (:documentation "Custom application based on NINGLE:APP"))

(defparameter *couchdb*
  "*REQUEST-ENV* will be dynamically bound to the environment context
of HTTP requests")





(defun couchdb-middleware (app)
  "A custom middleware which wraps a NINGLE:APP and injects additional
metadata into the environment for HTTP handlers/controllers as part of
each HTTP request"
  (lambda (env)
    (setf (getf env :couchdb-middleware/client) (init-database "admin" "password"))
    (funcall app env)))

(defmethod lack.component:call ((app app) env)
  ;; Dynamically bind *REQUEST-ENV* for each request, so that ningle
  ;; routes can access the environment.
  (let ((*couchdb* env))
    (call-next-method)))

(defvar *app* (make-instance 'app))
#+end_src

#+RESULTS:
: *APP*
*** design map api
*** Submit documents

Importance:
#+begin_src lisp :tangle ./source/frontends/http.lisp
(setf (ningle:route *app* "/submit/:operation/:dtype/:id")
      #'(lambda (args)
          (format nil "~a" args)))
#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (ARGS)) {100871863B}>

*** Start webapp
#+begin_src lisp :tangle ./source/frontends/http.lisp
(couchdb-middleware *app*)
(defparameter *server* (clack:clackup *app* :address *listen-address* :port *port*))
#+end_src

#+RESULTS:
: #S(CLACK.HANDLER::HANDLER
:    :SERVER :HUNCHENTOOT
:    :SWANK-PORT NIL
:    :ACCEPTOR #<BORDEAUX-THREADS-2:THREAD "clack-handler-hunchentoot" {10051142F3}>)


* Main Entry
#+begin_src lisp :tangle ./source/main.lisp :results none
(in-package :starintel-gserver)
(defun main ())
#+end_src

* Tasks
All tasks can have a very general headline, but the NAME must be topic.possibpe-sub-topic.thing scheme.
This section is for [[https://github.com/TxGVNN/project-tasks][project-tasks]].
** Updates
#+Name: update.flake
#+begin_src shell :async :results output replace
nix flake update
direnv reload .
#+end_src

#+RESULTS: update.flake

#+RESULTS: Update flake
** Docker
*** Run a rabbitmq instance
#+Name: docker.run.rabbitmq
#+begin_src shell :async :results output replace :tangle start.sh
docker run -d -p 5672:5672 -p 15672:15672 -e RABBITMQ_USER=user -e RABBITMQ_PASS=password --name rabbitmq_org_dev  rabbitmq:3.13.1-management
#+end_src

#+RESULTS: docker.run.rabbitmq
: 4f99c21797bbdc4e0f9b8154ad10d5d54789b95dae4ee7b916c8d3d962e0f9e8

#+RESULTS: Start Rabbitmq

*** Kill Rabbitmq
#+Name: docker.kill.rabbitmq
#+begin_src shell :async :results output replace
docker kill rabbitmq_org_dev
#+end_src


*** List Docker PS
#+Name: docker.ps
#+begin_src shell :async :results output replace
docker ps
#+end_src
* Footnotes

[fn:1] https://gist.github.com/dnaeon/3a3f86dea1096db5a9231d1f56a565e2
