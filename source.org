#+title: Source
#+STARTUP: show2levels

* Ideas
The main idea of this project is to have a single, closed source api interface that will be the SINGLE source for starintel data

** TODO allow it to be extended [0/4]
*** TODO Simple data transform system
*** TODO Simple map-reduce over rabbitmq
*** IDEA Move the config vars into a container?


** IDEA Transformer map reduce rabbit queue.


* Packaging

Given the org-mode file

** Makefile
#+begin_src makefile :tangle Makefile :comments link
##
# Starintel Gserver
#
# @file
# @version 0.1

LISP ?= sbcl

all: test

run:
	$(LISP) --load run.lisp

build:
	$(LISP)	--non-interactive \
		--load source/starintel-gserver.asd \
		--eval '(ql:quickload :starintel-gserver)' \
		--eval "(sb-ext:save-lisp-and-die \"star-server\" :toplevel 'starintel-gserver::main :executable t :compression t)"
install:
	cp star-server /usr/local/bin

clean:
	rm -f ./star-server
#+end_src

** Nix

#+begin_src nix :tangle flake.nix :comments link
{
  description = "Starintel API server that routes the data through msg queues.";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }:
    let
      pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in
    {
      devShell.x86_64-linux =
        pkgs.mkShell {
          buildInputs = with pkgs; [
            pkg-config
            sbcl
            openssl
            rabbitmq-c
            libffi
            sqlite
          ];
          shellHook = ''
            export LD_LIBRARY_PATH=${pkgs.lib.makeLibraryPath([pkgs.openssl pkgs.rabbitmq-c pkgs.libffi pkgs.sqlite])}
          '';
        };
    };
}

#+end_src

Here is
#+begin_src sh
use flake
# When we run make in prod it will gen defaults
# Debug is just for testing
export BUILD_MODE="DEV"
use flake
export COUCHDB_HOST="127.0.0.1"
export COUCHDB_PORT=5984
export COUCHDB_SCHEME="http"
export COUCHDB_USER="admin"
export COUCHDB_PASSWORD="password"
export COUCHDB_DATABASE="starintel"

#+end_src

#+RESULTS:
: CONTAINER ID   IMAGE                             COMMAND                  CREATED        STATUS      PORTS                                                                                                      NAMES
: d421e7dea3a1   zhaowde/rotating-tor-http-proxy   "/bin/sh -c /start.sh"   3 months ago   Up 8 days   3128/tcp, 0.0.0.0:1444->1444/tcp, :::1444->1444/tcp, 4444/tcp, 0.0.0.0:3128->3218/tcp, :::3128->3218/tcp   docker-rotating-tor-1

** Lisp stuff
*** ASDF
Here is the system def for it.
#+begin_src lisp :tangle source/starintel-gserver.asd :comments link
(asdf:defsystem :starintel-gserver
  :version      "0.1.0"
  :description  "hackable/moddable starintel acess api."
  :author       "nsaspy@airmail.cc"
  :license      "GPL v3"
  :serial t
  :build-operation program-op
  :build-pathname "foobar-command" ;; shell name
  :entry-point "foobar::start-foobar" ;; thunk
  :components   (
                 (:file "package")
                 (:file "gserver-settings" :depends-on ("package"))
                 (:file "init" :depends-on ("gserver-settings"))
                 (:file "actors" :depends-on ("gserver-settings"))
                 (:file "rabbit" :depends-on ("actors" "gserver-settings"))
                 (:file "frontends/http-api" :depends-on ("gserver-settings"))
                 (:file "main" :depends-on ("actors" "rabbit" "package" "gserver-settings" "frontends/http-api")))

  :depends-on   (#:starintel #:cl-couch #:serapeum  #:alexandria #:cl-rabbit #:sento #:babel #:cl-json :uuid #:anypool
                             #:clack #:ningle #:hunchentoot #:clingon #:slynk))
 #+end_src

 Client system for cli document tool.

 #+begin_src lisp :tangle ./source/star-cli.asd :results none :commentd link
(asdf:defsystem :star-cli
  :version      "0.1.0"
  :description  "Api client for gserver and basic doc tool"
  :author       " <unseen@flake>"
  :serial       t
  :license      "GNU GPL, version 3"
  :components   ((:file "cli"))
  :depends-on   (#:starintel #:cl-json #:uuid))

 #+end_src

 Api  Client system

 #+begin_src lisp :tangle ./source/starintel-gserver-client.asd :results none :commentd link
(asdf:defsystem :starintel-gserver-client
  :version      "0.1.0"
  :description  "Api client for gserver."
  :author       " <unseen@flake>"
  :serial       t
  :license      "GNU GPL, version 3"
  :components   ((:file "api-client"))
  :depends-on   (#:starintel #:cl-json #:uuid #:dexador #:cl-csv #:cl-csv-data-table #:data-table))

 #+end_src



*** Namespace setup
I prefer to have my namespace done in a somewhat hierarchical style.

So lets say you want to make a http frontend api, there is going to be the namespace for it:
- star.frontends.http

And a database namespace would be:
- star.database.<database-type-or-name>


#+begin_src lisp :tangle ./source/frontends/package.lisp :results none :comments link
(uiop:define-package   :star.frontend.http-api
  (:nicknames :frontend.http-api)
  (:use       :cl :ningle)
  (:documentation "doc"))
#+end_src

gserver namespace, general top level.

#+begin_src lisp :tangle ./source/package.lisp :comments link
(uiop:define-package   :starintel-gserver
  (:nicknames :star)
  (:use       :cl)
  (:export
   #:init-db
   #:*rabbit-password*
   #:*rabbit-user*
   #:*rabbit-port*
   #:*rabbit-address*
   #:*http-scheme*
   #:*http-key-file*
   #:*http-cert-file*
   #:*http-api-base-path*
   #:*http-api-port*
   #:*http-api-address*
   #:*couchdb-default-database*
   #:*couchdb-host*
   #:*couchdb-port*
   #:*couchdb-user*
   #:*couchdb-password*
   #:*couchdb-scheme*))
#+end_src

#+RESULTS:
: #<PACKAGE "STARINTEL-GSERVER">

#+begin_src lisp :tangle ./source/package.lisp :results none :comments link
(uiop:define-package   :starintel-gserver.rabbit
  (:nicknames :star.consumers)
  (:use       :cl)
  (:documentation "Rabitmq namespace")
  (:export
   #:start-rabbit-document-thread
   #:with-rabbit-send
   #:with-rabbit-recv
   #:emit-document))
#+end_src

#+begin_src lisp :tangle ./source/package.lisp :results none :comments link
(uiop:define-package   :starintel-gserver-http-api
  (:nicknames :star.frontends.http-api)
  (:use       :cl)
  (:documentation "doc"))
#+end_src

#+begin_src lisp :tangle ./source/cli.lisp :results none :comments link
(uiop:define-package   :star-cli
  (:nicknames :star.cli)
  (:use       :starintel)
  (:documentation "doc"))

#+end_src
#+begin_src lisp :tangle ./source/api-client.lisp :results none :comments link
(uiop:define-package   :starintel-gserver-client
  (:nicknames :star.api.client)
  (:use       :cl)
  (:documentation "doc"))
#+end_src
** Docker
#+begin_src Dockerfile :tangle ./Dockerfile :comments none
FROM fukamachi/sbcl:latest as build
# Install required packages
RUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt set -x; \
    apt-get update && \
    apt-get install -y \
    make \
    libffi-dev \
    pkg-config \
    librabbitmq-dev \
    build-essential

# Create a user and set up working directory
RUN ros setup

# Copy dependencies
COPY . /root/

# Set up symbolic links using ln
RUN ln -s /root/deps/ /root/common-lisp
WORKDIR /root/
RUN make build
RUN make install
FROM build as star-router
ENV BUILD_MODE="DEV" \
    COUCHDB_HOST="127.0.0.1" \
    COUCHDB_PORT=5984 \
    COUCHDB_SCHEME="http" \
    COUCHDB_USER="admin" \
    COUCHDB_PASSWORD="password" \
    COUCHDB_DATABASE="starintel" \
    HTTP_API_LISTEN_ADDRESS="localhost" \
    RABBITMQ_HOST="rabbitmq" \
    RABBITMQ_PORT=5672
# Expose port 5000
EXPOSE 5000

# Entrypoint to start the server
ENTRYPOINT ./star-server
CMD [./star-server]
#+end_src
** TODO Kali/parrot
#+Name: Install docker
#+begin_src shell :async :results output replace :tangle parrot_kali.sh :comments link
install_docker() {
    sudo apt update
    sudo apt install -y apt-transport-https ca-certificates curl software-properties-common
    curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt update
    sudo apt install -y docker-ce docker-ce-cli containerd.io
    sudo apt install -y docker-compose
    sudo usermod -aG docker $USER

}


install_docker

#+end_src

* Settings
#+begin_src lisp :tangle ./source/gserver-settings.lisp :results none :comments link
(in-package :star)
(defparameter *couchdb-host* (or (uiop:getenv "COUCHDB_HOST") "127.0.0.1") "The Couchdb host to use.")
(defparameter *couchdb-port* 5984 "The Couchdb port to use.")
(defparameter *couchdb-default-database* (or (uiop:getenv "COUCHDB_DATABASE") "starintel") "the default database name to use.")
(defparameter *couchdb-target-database* "starintel-targets" "the database to be used for target data.")
(defparameter *couchdb-scheme* "http" "what http scheme to use. set to http or https")
(defparameter *couchdb-user* (or (uiop:getenv "COUCHDB_USER") "admin") "couchdb user")
(defparameter *couchdb-password* (or (uiop:getenv "COUCHDB_PASSWORD") "password") "couchdb user password")
#+end_src
** Frontends
*** Http Settings
This section contains only settings related to http frontend

**** Listen Address

#+begin_src lisp :tangle ./source/gserver-settings.lisp :comments link
(defparameter *http-api-address* (or (uiop:getenv "HTTP_API_LISTEN_ADDRESS") "localhost") "the listen address")
(defparameter *http-api-port* 5000  "the port the api server listen on")
(defparameter *http-api-base-path* "/api" "the base url to use for the api endpoint")
(defparameter *http-cert-file* nil "path to the http api cert providing https")
(defparameter *http-key-file* nil "path to the http cert providing https")
(defparameter *http-scheme* 'http "use https or not.")
#+end_src
** Rabbit mq settings
*** Authentication
#+begin_src lisp :tangle ./source/gserver-settings.lisp :comments link
(defparameter *rabbit-address* (or (uiop:getenv "RABBITMQ_ADDRESS") "localhost") "The address rabbitmq is running on.")
(defparameter *rabbit-port* 5672 "The port that rabbitmq is listening on.")
(defparameter *rabbit-user* "guest" "the username for rabbimq")
(defparameter *rabbit-password* "guest" "the password for the rabbitmq user.")

(eval-when (:execute)
  )
#+end_src

#+RESULTS:
: *RABBIT-PASSWORD*


* Actors

** Actor system setup
The sen to package expects us to be in the sento user package.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(in-package :sento-user)
(defparameter *sys* nil "the main actor system")
(defun start-actor-system ()
  (setf *sys* (make-actor-system '(:dispatchers
                                   (:pinned (:workers 4 :strategy :random))
                                   :timeout-timer
                                   (:resolution 500 :max-size 1000)
                                   :eventstream
                                   (:dispatcher-id :shared)
                                   :scheduler
                                   (:enabled :true :resolution 100 :max-size 500)))))
 #+end_src

** Eventing

Sento supports events but I can only use a symbol or a simple string. it supports matching by class types too.

This allows actors to filter out messages by topic.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defclass message-event ()
  ((topic :initarg :topic :initform (error "Topic for event stream is required.") :reader message-topic)
   (data :initarg :data :type string :initform "" :reader message-data))
  (:documentation "A basic class that holds message event topic and data"))
#+end_src

The interface for matching topics is ~topic-match-p~.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defgeneric topic-match-p (msg topic)
  (:documentation "generic interface that matches if a msg matches the subbed topic."))

(defmethod topic-match-p ((msg message-event) topic)
  "Return T if topic matches msg's topic"
  (string= topic (string-downcase (message-topic msg))))


(defun new-event (&key topic data (eventstream *sys*))
  "Create an publish a new message-event.
    This is a simple wrapper around the publish from sento."
  (publish eventstream (make-instance 'message-event :topic topic :data data)))


(defmacro with-topics ((&key msg topics) &body body)
  "A macro that will check if MSG topic "
  `(loop for topic in ,topics

         if (topic-match-p ,msg topic)
           do (progn ,@body)))
#+end_src

Here is a simple example of an actor that works with person objects.
#+begin_src lisp
(ac:actor-of *sys* :name "personator"
                   :init (lambda (self)
                           (ev:subscribe self self 'message-event))
                   :receive (lambda (msg)
                              (with-topics (:msg msg :topics '("New-Person"))
                                (format nil "~a" (starintel:doc-id msg)))))

#+end_src
** API
Actors need to interact with external services like couchdb.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defun make-api-msg (sender data)
  (cons data sender))
#+end_src

*** Targets

This agent will story the symbol name of the agent and the actor for which they are registered.

#+begin_src lisp :tangle ./source/actors.lisp :results  none :comments link
(defparameter *actor-index-agent* nil)

(defun start-actor-index (system)
  (setf *actor-index-agent* (make-agent #'serapeum:dict system)))

(defun register-actor (actor-name actor-symbol)
  (setf (agent-get *actor-index-agent* #'identity) (serapeum:dict* (agent-get *actor-index-agent*) actor-name actor-symbol)))

(defun get-dest-actor (actor)
  (serapeum:@  (agent-get *actor-index-agent* #'identity) actor))

(defun route-target (target actor)
  (let ((dest (get-dest-actor actor)))
    (format t "got ~a" actor)
    (when dest
      (tell dest target))))
#+end_src

*** Couchdb
**** Couchdb client agent
#+begin_src lisp :tangle ./source/actors.lisp :results none :comments :link
(in-package :sento-user)

(defparameter *couchdb-agent* nil)
(defun make-couchdb-agent (context client
                           &key (error-fun nil) (dispatcher-id :shared))
  (make-agent (lambda ()
                client)
                context dispatcher-id))


(defun couchdb-agent-client (agent)
  (agt:agent-get agent #'identity))


(defun couchdb-agent-insert (agent database document)
  (cl-couch:create-document (couchdb-agent-client agent) database document))

(defun couchdb-agent-update (agent database document revision)
  (cl-couch:create-document (couchdb-agent-client agent) (jsown:to-json
                                                        (jsown:extend-js (jsown:parse document)
                                                          ("_rev" revision)))))

(defun couchdb-agent-delete (agent database document-id)
  (cl-couch:delete-document (couchdb-agent-client agent) database document-id))

(defun couchdb-agent-get-view (agent database ddoc view query-json)
  (cl-couch:get-view (couchdb-agent-client agent) database ddoc view query-json))


(defun start-couchdb-agent (system)
    (let ((client (couch:new-couchdb star:*couchdb-host* star:*couchdb-port*)))
      (couch:password-auth client star:*couchdb-user* star:*couchdb-password*)
      (setf *couchdb-agent* (make-couchdb-agent system client))))
#+end_src
**** Client Pooling
Couchdb is the main database I have used for many projects, I am using [[https://github.com/lost-rob0t/cl-couch][cl-couch]] for the database client. It doesnt use async so I need to setup a resource pools, for that I use anypool.


#+begin_src lisp  :results none :comments link
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb star:*couchdb-host* star:*couchdb-port* :scheme star:*couchdb-scheme*)))
                                    (cl-couch:password-auth client star:*couchdb-user* star:*couchdb-password*)
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src

start--pool-monitoring is used for checking the total active count from the couchdb client pool.
it is only used internally for debugging.

#+begin_src lisp  :results none :comments link
(defvar *my-thread* nil)

(defun start--pool-monitoring ()
  (setf *my-thread*
        (bt:make-thread
         (lambda ()
           (loop
             do (progn (format t "Active count: ~a, Idle count: ~a~%"
                               (anypool:pool-active-count *couchdb-pool*)
                               (anypool:pool-idle-count *couchdb-pool*))
                       (force-output)
                       (sleep 1))
             finally (bt:thread-yield))))))

(defun stop--pool-monitoring ()
  (when *my-thread*
    (bt:destroy-thread *my-thread*)
    (setf *my-thread* nil)))
#+end_src

**** couchdb-insert actor
This actor will insert documents into couchdb.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-inserts* nil)
(defun start-couchdb-inserts (system)
  (setf *couchdb-inserts* (actor-of system
                                    :name "*couchdb-inserts*"
                                    :receive (lambda (msg)
                                               (let ((destination-db star:*couchdb-default-database*))
                                                 (format t "inserting: ~a" msg)
                                                 (when (not (cl-couch:document-exists-p (couchdb-agent-client *couchdb-agent*) destination-db (jsown:val (cdr msg) "_id")))
                                                   (print (couchdb-agent-insert *couchdb-agent* destination-db (jsown:to-json* (cdr msg)))))
                                                 (force-output))))))

#+end_src
**** couchdb-get actor
This actor is to be used by other actors wishing to interact with the couchdb database.
The message to be sent MUST be ~(cons sender data)~.
#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-gets* nil "The Couchdb actor responsible for handling document gets.")

(defun start-couchdb-gets (system)
  (setf *couchdb-gets* (ac:actor-of system :name "*couchdb-gets*"
                                           :receive (lambda (msg)
                                                      (let ((pool *couchdb-pool*)
                                                            (db (uiop:getenv "COUCHDB_DATABASE")))
                                                        (with-context (*sys*)
                                                          (anypool:with-connection (client pool)
                                                            (task-async (lambda ()
                                                                          (handler-case
                                                                              (cl-couch:get-document client db (car msg))
                                                                            (dex:http-request-not-found (e) nil)
                                                                            (dex:http-request-unauthorized (e) nil)))
                                                                        :on-complete-fun (lambda (doc)
                                                                                           (reply doc (cdr msg)))))))))))
#+end_src

**** TODO finish bulk insert actor

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
;; (defparameter *couchdb-bulk-insert* (ac:actor-of *sys*
;;                                                  :name "*couchdb-bulk-insert*"
;;                                                  :receive (lambda (msg)
;;                                                             (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
;;                                                                   (pool *couchdb-pool*))
;;                                                               (anypool:with-connection (client pool)
;;                                                                 (cl-couch:bulk-create-documents client destination-db msg :batch "normal"))))))
#+end_src


** IDEA Document Handler
#+begin_src lisp
(defun start-document-handler-actor ()
  (defparameter *document-handler* (ac:actor-of *sys*)))
#+end_src
** Target Actor

#+begin_src lisp :tangle ./source/actors.lisp :results  none :comment link
(defparameter *targets* nil)
(defparameter *target-filter* ())
(defun get-targets (client database)
  (let ((jdata (jsown:val-safe (jsown:parse (cl-couch:get-view client star:*couchdb-default-database* "targets" "actor-targets" (jsown:to-json (jsown:new-js
                                                                                                                                                ("include_docs" "true"))))) "rows")))
    (when (> 0 (length jdata))
      (loop for row in jdata
            for doc = (jsown:val row "doc")
            for actor = (jsown:val doc "actor")
            collect (cons actor doc)))))

(defun sumbit-target (target &optional (first-time t))
  "Create a message for the *targets* actor."
  (tell *targets*  (if first-time
                       (cons t target)
                       (cons nil target))))

(defun first-time-p (msg)
  (car msg))

(defun target-transient-p (target)
  (when (jsown:val-safe target "transient")
    t))

(defun start-target-loader ()
  (let (targets (get-targets (anypool:with-connection (client *couchdb-pool*)
                               (get-targets client star:*couchdb-default-database*))))
    (loop for target in targets
          do (submit-target target t))))


(defun start-target-actor (system)
  (setf *targets* (actor-of system
                            :name "*targets*"
                            :receive (lambda (msg)
                                       (let* ((target (cdr msg))
                                              (actor (jsown:val target "actor"))
                                              (delay (jsown:val-safe target "delay")))
                                         (print target)
                                         (when (not (get-dest-actor actor))
                                           (progn (print "not in system")
                                                  (star.rabbit:emit-document  "documents" (format nil "actors.~a.new-target" actor)
                                                                             (jsown:to-json target)
                                                                             :host star:*rabbit-address*
                                                                             :port star:*rabbit-port*
                                                                             :username star:*rabbit-user* :password star:*rabbit-password*)))

                                         (when (and (get-dest-actor actor) (jsown:val target "recurring") (first-time-p msg))
                                           (wt:schedule-recurring *target-timer* 0.0 delay (lambda ()
                                                                                             (submit-target target nil))
                                                                  (jsown:val target "target")))
                                         (if (and (get-dest-actor actor) (not (first-time-p msg)))
                                             (route-target target actor)))))))

#+end_src


#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *target-timer* nil)
(defun start-target-timer ()
  (setf *target-timer* (wt:make-wheel-timer :resolution 10 :max-size 1000)))
#+end_src



** actor entry point

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defun start-actors ()
  (start-actor-system)
  (start-couchdb-agent *sys*)
  (start-actor-index *sys*)
  (start-couchdb-gets *sys*)
  (start-couchdb-inserts *sys*)
  (start-target-timer)
  (start-target-actor *sys*))
#+end_src

In order to compile the actor system must be stop

* RabbitMQ

** Macro Wrappers
The [[https://github.com/lokedhs/cl-rabbit][cl-rabbit]] lib is a bit lower level then I want to work with so I will create a basic macros to make the interface nicer.

I am not sure if injecting the msg var is a good idea.
I really would *prefer* if this is considered "fine".

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(in-package :star.consumers)

(defmacro with-rabbit-recv ((queue-name exchange-name exchange-type routing-key &key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)
         (cl-rabbit:exchange-declare conn 1 ,exchange-name ,exchange-type)

         (cl-rabbit:queue-declare conn 1 :queue ,queue-name :durable ,durable :auto-delete ,auto-delete :exclusive ,exclusive)
         (cl-rabbit:queue-bind conn 1 :queue ,queue-name :exchange ,exchange-name :routing-key ,routing-key)

         (cl-rabbit:basic-consume conn 1 ,queue-name)
         (loop
           for result = (cl-rabbit:consume-message conn)
           for msg = (cl-rabbit:envelope/message result)
           do (handler-case (progn
                              ,@body
                              (cl-rabbit:basic-ack conn 1 (cl-rabbit:envelope/delivery-tag result)))
                (error (e) (cl-rabbit:basic-nack conn 1 (cl-rabbit:envelope/delivery-tag result) :requeue t))))))))

(defun emit-document (exchange routing-key body &key (properties nil)
                                                             (immediate nil)
                                                             (mandatory nil)
                                                             (port star:*rabbit-port*)
                                                             (host star:*rabbit-address*)
                                                             (username star:*rabbit-user*)
                                                             (password star:*rabbit-password*)
                                                             (vhost "/"))
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket host port)
      (when (and username password)
        (cl-rabbit:login-sasl-plain conn vhost username password))
      (cl-rabbit:with-channel (conn 1)
        (cl-rabbit:basic-publish conn 1 :routing-key routing-key :exchange exchange :mandatory mandatory :immediate immediate :properties properties :body body)))))
#+end_src
** Handle New Document consumers

Take a rabbimq message and parse it.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun message->string (msg &key (encoding :utf-8))
  "take a rabbitmq message and return the boddy as a string"
  (babel:octets-to-string (cl-rabbit:message/body msg) :encoding encoding))

                                        ;TODO
(defun message->object (msg)
  "Tale a rabbbitmq message and return a object. The object that will be returned depends on the message property 'dtype`.")

(defun handle-new-document (msg)
  "Handles any new incoming documents and sends it to the appropriate actors."
  (let* ((props (cl-rabbit:message/properties msg))
         (dtype (assoc :type props :test #'equal))
         (body (jsown:parse (message->string msg))))
    (cons (cdr dtype) body)))
#+end_src

Start the rabbit new document monitoring thread.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none :comments link
(defun start-rabbit-document-thread (&key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*))
  (loop for i from 0 to 4
        do (bt:make-thread
            (lambda ()
              (with-rabbit-recv ("injest" "documents" "topic" "documents.new.#" :auto-delete nil :exclusive nil)
                (let (
                      (data (handle-new-document msg)))
                     (format t "document-thread: ~{~a, ~}~%" data)
                     (force-output)
                     (when (null (jsown:val-safe (cdr data) "transient"))
                       (ignore-errors (sento-user::tell sento-user::*couchdb-inserts* data))))))
            ;; (sento-user::publish sento-user::*sys* (sento-user::new-event :topic (string-downcase (car data)) :data (cdr data)))


             :name "*new-documents*")))

#+end_src
** Handle New Target consumers

return the target

#+begin_src lisp :tangle ./source/rabbit.lisp :results  none :comments link
(defun handle-new-target (msg)
  "Handles any new incoming documents and sends it to the appropriate actors."
  (let* ((props (cl-rabbit:message/properties msg))
         (body (message->string msg)))
    body))
    #+end_src

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun start-rabbit-targets-thread (&key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*))
  (loop for i from 0 to 1
        do (bt:make-thread
            (lambda ()
              (with-rabbit-recv ("injest-targets" "documents" "topic" "documents.new.target.*" :auto-delete nil :exclusive nil)
                (let ((data (jsown:parse (handle-new-target msg))))
                  (sento-user::tell sento-user::*targets* (cons 1 data)))
                  (force-output))



             :name "*new-targets-consumer*"))))
#+end_src
** quick test functions

These functions are for quick debugging of the rabbitmq.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun test-make-doc ()

  (with-output-to-string (str) (cl-json:encode-json (starintel:set-meta (make-instance  'starintel:person :id (uuid:make-v4-uuid) :lname "doe" :fname "john") "starintel") str)))

(defun test-send ()
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket "localhost" 5672)
      (cl-rabbit:login-sasl-plain conn "/" "guest" "guest")
      (cl-rabbit:with-channel (conn 1)
        (cl-rabbit:basic-publish conn 1
                                 :exchange "documents"
                                 :routing-key "documents.new.Person"
                                 :body (test-make-doc)
                                 :properties '((:headers . (("dtype"  . "Person")))))))))
#+end_src
** Map Reduce
*** Ideas
Last updated: <2024-04-18 Thu>
**** Basic Data transform
Map reduce will allow for a simple, realtime data enrichment system.

An example use would be creating and comparing fingerprints for documents.
***** transformer context
#+begin_src lisp :tangle ./source/transform.lisp :results none :comments link
((defclass transformer ()
   ((socket :initarg :socket :accessor transformer-socket :allocation :instance)
    (channel))
   (:documentation "doc")))
#+end_src
* Databases
** Couchdb
*** Views
**** Data View
Analytics views county documents by their type.

#+begin_src json :tangle ./source/views/data.json
{"_id":"_design/data","views":{"count_by_dtype":{"map":"function(doc) {\n  if (doc.dtype && doc.dtype !== \"Relation\") {\n    emit(doc.dtype, 1);\n  }\n}","reduce":"_count"},"dataset_size":{"reduce":"_count","map":"function (doc) {\n  emit(doc.dataset, 1);\n  \n}"},"total":{"reduce":"_sum","map":"function (doc) {\n  emit(null, 1);\n}"}},"language":"javascript"}
#+end_src

**** Relations View
Very basic graph index, simply way of getting neighbors

#+begin_src json :tangle ./source/views/relations.json
{"_id":"_design/relations","views":{"outgoing-count":{"reduce":"_count","map":"function (doc) {\n  if (doc.dtype === \"Relation\") {\n    emit(doc.source, 1);\n  }\n}"},"incoming-count":{"reduce":"_count","map":"function (doc) {\n  if (doc.dtype === \"Relation\") {\n    emit(doc.target, 1);\n  }\n}"},"edges":{"map":"function (doc) {\n  if(doc.dtype===\"Relation\"){\n  emit(doc.target, {\"_id\": doc._id, \"note\": doc.note});\n}}","reduce":"function(keys, values, rereduce) {\n  var results = [];\n  if (!rereduce) {\n    values.forEach(function(value) {\n      if (results.indexOf(value) === -1) {\n        results.push(value);\n      }\n    });\n  } else {\n    values.forEach(function(arr) {\n      arr.forEach(function(value) {\n        if (results.indexOf(value) === -1) {\n          results.push(value);\n        }\n      });\n    });\n  }\n  return results;\n}"},"neighbors":{"reduce":"function(keys, values, rereduce) {\n  var results = [];\n  if (!rereduce) {\n    values.forEach(function(value) {\n      if (results.indexOf(value) === -1) {\n        results.push(value);\n      }\n    });\n  } else {\n    values.forEach(function(arr) {\n      arr.forEach(function(value) {\n        if (results.indexOf(value) === -1) {\n          results.push(value);\n        }\n      });\n    });\n  }\n  return results;\n}","map":"function (doc) {\n  if(doc.dtype===\"Relation\"){\n  emit(doc.source, doc.target);  \n}}"},"edge-note":{"map":"function (doc) {\n  if(doc.dtype == \"Relation\"){\n  emit(doc.note, null);\n}}","reduce":"_count"}},"language":"javascript"}

#+end_src

**** Search View
Full Text search index

#+begin_src json :tangle ./source/views/search.json
{"_id":"_design/search","views":{},"language":"javascript","indexes":{"fts":{"analyzer":{"name":"perfield","default":"standard","fields":{}},"index":"function(doc) { \n  index('dataset', doc.dataset, {\"store\": \"yes\", \"field\": \"dataset\"});\n  index('date_added', doc.date_added, {\"store\": \"yes\", \"field\": \"date_added\"});\n  index('date_updated', doc.date_updated, {\"store\": \"yes\", \"field\": \"date_updated\"});\n  index('dtype', doc.dtype, {\"store\": \"yes\", \"field\": \"dtype\"});\n  if (doc.dtype == \"Entity\") {\n        var total = doc.etype + \" \" + doc.eid;\n        index('etype', doc.etype, {\"store\": \"yes\", \"field\": \"etype\"});\n        index('eid', doc.eid, {\"store\": \"yes\", \"field\": \"eid\"});\n        if (doc.dataset) {\n            index('dataset', doc.dataset, {\"store\": \"yes\", \"field\": \"dataset\"});\n        }\n        if (doc.date_added) {\n            index('date_added', doc.date_added, {\"store\": \"yes\", \"field\": \"date_added\"});\n        }\n        if (doc.date_updated) {\n            index('date_updated', doc.date_updated, {\"store\": \"yes\", \"field\": \"date_updated\"});\n        }\n    }\n    if (doc.dtype == \"Org\") {\n        var total = doc.reg + \" \" + doc.country + \" \" + doc.name + \" \" + doc.website + \" \" + doc.bio;\n        index('reg', doc.reg, {\"store\": \"yes\", \"field\": \"reg\"});\n        index('country', doc.country, {\"store\": \"yes\", \"field\": \"country\"});\n        index('name', doc.name, {\"store\": \"yes\", \"field\": \"name\"});\n        index('website', doc.website, {\"store\": \"yes\", \"field\": \"website\"});\n        index('bio', doc.bio, {\"store\": \"yes\", \"field\": \"bio\"});\n    }\n    if (doc.dtype == \"Person\") {\n        var total = doc.fname + \" \" + doc.mname + \" \" + doc.lname + \" \" + doc.bio + \" \" + doc.dob + \" \" + doc.gender + \" \" + doc.race + \" \" + doc.region + \" \" + JSON.stringify(doc.misc);\n        index('fname', doc.fname, {\"store\": \"yes\", \"field\": \"fname\"});\n        index('mname', doc.mname, {\"store\": \"yes\", \"field\": \"mname\"});\n        index('lname', doc.lname, {\"store\": \"yes\", \"field\": \"lname\"});\n        index('bio', doc.bio, {\"store\": \"yes\", \"field\": \"bio\"});\n        index('dob', doc.dob, {\"store\": \"yes\", \"field\": \"dob\"});\n        index('gender', doc.gender, {\"store\": \"yes\", \"field\": \"gender\"});\n        index('race', doc.race, {\"store\": \"yes\", \"field\": \"race\"});\n        index('region', doc.region, {\"store\": \"yes\", \"field\": \"region\"});\n        if (doc.misc) {\n            index('misc', JSON.stringify(doc.misc), {\"store\": \"yes\", \"field\": \"misc\"});\n        }\n    }\n        if (doc.dtype == \"Message\") {\n        var total = doc.message + \" \" + doc.platform + \" \" + doc.user + \" \" + doc.message_id + \" \" + doc.reply_to + \" \" + doc.group + \" \" + doc.channel + \" \" + JSON.stringify(doc.mentions);\n        index('message', doc.message, {\"store\": \"yes\", \"field\": \"message\"});\n        index('platform', doc.platform, {\"store\": \"yes\", \"field\": \"platform\"});\n        index('user', doc.user, {\"store\": \"yes\", \"field\": \"user\"});\n        index('message_id', doc.message_id, {\"store\": \"yes\", \"field\": \"message_id\"});\n        index('reply_to', doc.reply_to, {\"store\": \"yes\", \"field\": \"reply_to\"});\n        index('group', doc.group, {\"store\": \"yes\", \"field\": \"group\"});\n        index('channel', doc.channel, {\"store\": \"yes\", \"field\": \"channel\"});\n        if (doc.mentions) {\n            index('mentions', JSON.stringify(doc.mentions), {\"store\": \"yes\", \"field\": \"mentions\"});\n        }\n    }\n    if (doc.dtype == \"SocialMPost\") {\n        var total = doc.content + \" \" + doc.user + \" \" + JSON.stringify(doc.replies) + \" \" + JSON.stringify(doc.media) + \" \" + doc.replyCount + \" \" + doc.repostCount + \" \" + doc.url + \" \" + JSON.stringify(doc.links) + \" \" + JSON.stringify(doc.tags) + \" \" + doc.title + \" \" + doc.group + \" \" + doc.replyTo;\n        index('content', doc.content, {\"store\": \"yes\", \"field\": \"content\"});\n        index('user', doc.user, {\"store\": \"yes\", \"field\": \"user\"});\n        if (doc.replies) {\n            index('replies', JSON.stringify(doc.replies), {\"store\": \"yes\", \"field\": \"replies\"});\n        }\n        if (doc.media) {\n            index('media', JSON.stringify(doc.media), {\"store\": \"yes\", \"field\": \"media\"});\n        }\n        index('replyCount', doc.replyCount, {\"store\": \"yes\", \"field\": \"replyCount\"});\n        index('repostCount', doc.repostCount, {\"store\": \"yes\", \"field\": \"repostCount\"});\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n        if (doc.links) {\n            index('links', JSON.stringify(doc.links), {\"store\": \"yes\", \"field\": \"links\"});\n        }\n        if (doc.tags) {\n            index('tags', JSON.stringify(doc.tags), {\"store\": \"yes\", \"field\": \"tags\"});\n        }\n        index('title', doc.title, {\"store\": \"yes\", \"field\": \"title\"});\n        index('group', doc.group, {\"store\": \"yes\", \"field\": \"group\"});\n        index('replyTo', doc.replyTo, {\"store\": \"yes\", \"field\": \"replyTo\"});\n    }\n    if (doc.dtype == \"Breach\") {\n        var total = doc.total + \" \" + doc.description + \" \" + doc.url;\n        index('total', doc.total, {\"store\": \"yes\", \"field\": \"total\"});\n        index('description', doc.description, {\"store\": \"yes\", \"field\": \"description\"});\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n    }\n    if (doc.dtype == \"Email\") {\n        var total = doc.user + \" \" + doc.domain + \" \" + doc.password;\n        index('user', doc.user, {\"store\": \"yes\", \"field\": \"user\"});\n        index('domain', doc.domain, {\"store\": \"yes\", \"field\": \"domain\"});\n        index('password', doc.password, {\"store\": \"yes\", \"field\": \"password\"});\n    }\n    if (doc.dtype == \"EmailMessage\") {\n        var total = doc.body + \" \" + doc.subject + \" \" + doc.to + \" \" + doc.fromF + \" \" + doc.headers + \" \" + JSON.stringify(doc.cc) + \" \" + JSON.stringify(doc.bcc);\n        index('body', doc.body, {\"store\": \"yes\", \"field\": \"body\"});\n        index('subject', doc.subject, {\"store\": \"yes\", \"field\": \"subject\"});\n        index('to', doc.to, {\"store\": \"yes\", \"field\": \"to\"});\n        index('fromF', doc.fromF, {\"store\": \"yes\", \"field\": \"fromF\"});\n        if (doc.cc) {\n            index('cc', JSON.stringify(doc.cc), {\"store\": \"yes\", \"field\": \"cc\"});\n        }\n        if (doc.bcc) {\n            index('bcc', JSON.stringify(doc.bcc), {\"store\": \"yes\", \"field\": \"bcc\"});\n        }\n    }\n    if (doc.dtype == \"User\") {\n        var total = doc.url + \" \" + doc.name + \" \" + doc.platform + \" \" + JSON.stringify(doc.misc) + \" \" + doc.bio;\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n        index('name', doc.name, {\"store\": \"yes\", \"field\": \"name\"});\n        index('platform', doc.platform, {\"store\": \"yes\", \"field\": \"platform\"});\n        if (doc.misc) {\n            index('misc', JSON.stringify(doc.misc), {\"store\": \"yes\", \"field\": \"misc\"});\n        }\n        index('bio', doc.bio, {\"store\": \"yes\", \"field\": \"bio\"});\n    }\n      if (doc.dtype == \"Phone\") {\n        var total = doc.number + \" \" + doc.carrier + \" \" + doc.status + \" \" + doc.phone_type;\n        index('number', doc.number, {\"store\": \"yes\", \"field\": \"number\"});\n        index('carrier', doc.carrier, {\"store\": \"yes\", \"field\": \"carrier\"});\n        index('phone_type', doc.phone_type, {\"store\": \"yes\", \"field\": \"phone_type\"});\n    }\n    \n    if (doc.dtype == \"Web\") {\n        var total = doc.source;\n        index('source', doc.source, {\"store\": \"yes\", \"field\": \"source\"});\n    }\n    if (doc.dtype == \"Domain\") {\n        var total = doc.recordType + \" \" + doc.record + \" \" + doc.ip;\n        index('recordType', doc.recordType, {\"store\": \"yes\", \"field\": \"recordType\"});\n        index('record', doc.record, {\"store\": \"yes\", \"field\": \"record\"});\n        index('ip', doc.ip, {\"store\": \"yes\", \"field\": \"ip\"});\n    }\n    if (doc.dtype == \"Network\") {\n        var total = doc.org + \" \" + doc.asn.number + \" \" + doc.asn.subnet;\n        index('org', doc.org, {\"store\": \"yes\", \"field\": \"org\"});\n        index('asnNumber', doc.asn.number, {\"store\": \"yes\", \"field\": \"asnNumber\"});\n        index('subnet', doc.asn.subnet, {\"store\": \"yes\", \"field\": \"subnet\"});\n    }\n    if (doc.dtype == \"Host\") {\n        var total = doc.hostname + \" \" + doc.ip + \" \" + JSON.stringify(doc.ports) + \" \" + doc.os;\n        index('hostname', doc.hostname, {\"store\": \"yes\", \"field\": \"hostname\"});\n        index('ip', doc.ip, {\"store\": \"yes\", \"field\": \"ip\"});\n        if (doc.ports) {\n            index('ports', JSON.stringify(doc.ports), {\"store\": \"yes\", \"field\": \"ports\"});\n        }\n        index('os', doc.os, {\"store\": \"yes\", \"field\": \"os\"});\n    }\n    if (doc.dtype == \"Url\") {\n        var total = doc.url + \" \" + doc.content;\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n        index('content', doc.content, {\"store\": \"yes\", \"field\": \"content\"});\n    }\n\n    \n    \n}"}}}
#+end_src
**** Time View

Get documents based on time.

#+begin_src json :tangle ./source/views/time.json
{"_id":"_design/time","language":"javascript","views":{"dateAdded":{"map":"function (doc) {\n  emit(doc.date_added, doc._id);\n}","reduce":"_count"},"timeline":{"map":"function (doc) {\n  emit(doc._id, doc.date_added);\n}"}}}
#+end_src

**** Targets View

Get documents based on time.

#+begin_src json :tangle ./source/views/targets.json
{"_id": "_design/targets", "views": { "actor-targets": {"map": "function (doc) {\n  emit(doc.actor, doc.target);\n}"},"actor-target-count": {"reduce": "_count","map": "function (doc) {\n  emit(doc.actor, 1);\n}"},"target-count": {"reduce": "_sum","map": "function (doc) {\n  emit(doc.target, 1);\n}"}},"language": "javascript"}
#+end_src

*** Init database for first time
#+begin_src lisp :tangle ./source/init.lisp :results none
(in-package :starintel-gserver)

(defun init-views (client database)
  (let ((files (uiop:directory-files (uiop:merge-pathnames* "views/" (asdf:system-source-directory :starintel-gserver)))))
    (loop for file in files
          for jdata = (with-open-file (str file)
                        (format nil "~a~%" (read-line str)))
          do (cl-couch:create-document client database jdata))))

(defun init-db ()
  "Create the database, and all map-reduce views with it."
  (let* ((client (cl-couch:new-couchdb *couchdb-host* *couchdb-port* :scheme (string-downcase "http")))
         (database *couchdb-default-database*))
    (cl-couch:password-auth client *couchdb-user* *couchdb-password*)
    (handler-case (cl-couch:get-database client database)
      (dexador:http-request-not-found () (progn
                                           (cl-couch:create-database client database)
                                           (init-views client database))))))

#+end_src
* Frontends
Frontends  are basicly APi services that allow external stuff to interact with this system.
** asdf

** http-api

#+begin_src lisp :tangle ./source/frontends/http-api.lisp :result none :comments both
(in-package :star.frontends.http-api)
(defvar *app* (make-instance 'ningle:app))


#+end_src

*** Api Client
This object will be used to store the base url path and authentication.
#+begin_src lisp :tangle ./source/api-client.lisp :results none :comments link
(in-package :star.api.client)
(defclass star-client ()
  ((base-url :initform "http://127.0.0.1:5000" :initarg :base-url :accessor base-url)
   (headers :initform '(("Accept" . "application/json")
                        ("Content-Type" . "application/json")) :initarg :headers :accessor star-client-headers))
  (:documentation "The Starintel gserver api client"))

(defun make-url (client api-url &key (query nil))
  (if query
      (quri:merge-uris (quri:make-uri :path api-url :query (quri:url-encode-params query)) (base-url client))
      (quri:merge-uris (quri:make-uri :path api-url) (base-url client))))


(defmacro api-request (client path &key
                                     (stream nil)
                                     (query nil)
                                     (content nil)
                                     (method :get)
                                     (force-binary nil)
                                     (keep-alive t))


  `(let ((resp
           (dexador:request (make-url ,client ,path :query ,query)
                            :method ,method :headers (star-client-headers ,client) :content ,content :want-stream ,stream :keep-alive ,keep-alive :force-binary ,force-binary)))



     resp))
#+end_src

*** Couchdb client pool
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(in-package :star.frontends.http-api)
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") 5984 :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME")))))
                                    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src
*** TODO Authentication
*** TODO Targets [0/2]
**** Get Targets for actor
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(setf (ningle:route *app* "/targets/:actor" :method :get)
      #'(lambda (params)
          (let ((targets (loop for row in (anypool:with-connection (client *couchdb-pool*)
                                            (jsown:val (jsown:parse (cl-couch:get-view client star:*couchdb-default-database* "targets" "actor-targets" (jsown:to-json
                                                                                                                                                         (jsown:new-js
                                                                                                                                                           ("include_docs" "true")
                                                                                                                                                           ("keys" (list (cdr (assoc :actor params :test #'string=)))))))) "rows"))
                               collect (jsown:val row "doc"))))
            (jsown:to-json targets))))

#+end_src

***** example usage
#+begin_src http
GET 127.0.0.1:5000/targets/fediwatch-users
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Mon, 29 Apr 2024 02:39:55 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: [{"_id":"foo","_rev":"1-91936a7aa9ea16e64a8c0b584bc6c98a","version":"0.7.2","actor":"fediwatch-users","dataset":"fedi","target":"https://mastodon.social/@dylanabbott","delay":1,"recurring":true}]


***** api-client get-targets
#+begin_src lisp :tangle ./source/api-client.lisp :results none :comments link
(defmethod get-targets ((client star-client) actor-name)
  "Get all targets for ACTOR-NAME."
  (api-request client (format nil "/targets/~a" actor-name)))
#+end_src

**** TODO Create Target
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(setf (ningle:route *app* "/new/target/:actor" :method :post)
      #'(lambda (params)

          (let* ((actor  (cdr (assoc :actor params :test #'string=)))
                 (body (babel:octets-to-string  (lack.request:request-content (ningle:context :request)) :encoding :utf-8))
                 (routing-key (format nil "documents.new.target.~a" actor)))
            (star.rabbit:emit-document "documents" routing-key body :properties (list (cons :type "target")))
            body)))

#+end_src


#+RESULTS:

#+begin_src http
POST http://127.0.0.1:5000/new/target/fediwatch-timeline

{"_id":"test-agents1","version":"0.7.2","actor":"fediwatch","dataset":"fedi","target":"https://mastodon.social/@dylanabbott","delay":1,"recurring":true}
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Thu, 09 May 2024 20:03:22 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: {"_id":"test-agents1","version":"0.7.2","actor":"fediwatch","dataset":"fedi","target":"https://mastodon.social/@dylanabbott","delay":1,"recurring":true}

***** Api client new-target

#+begin_src lisp :tangle ./source/api-client.lisp :results none :comments link
(defmethod new-target ((client star-client) target-doc actor &optional (transient nil))
  "Insert new target."
  (if transient
      (api-request client (format nil "/new/target/~a" actor) :method :post
                                                              :content (jsown:to-json (jsown:extend-js (jsown:remkey  (jsown:parse target-doc) "options")
                                                                                        ("transient" t))))
      (api-request client (format nil "/new/target/~a" actor) :method :post
                                                              :content (jsown:to-json (jsown:remkey (jsown:parse  target-doc) "options")))))
#+end_src

****** api client import from csv
#+begin_src lisp :tangle ./source/api-client.lisp :results none
(defun read-targets-csv (targets-file)
  (let ((targets (data-table:select-columns  (cl-csv:get-data-table-from-csv targets-file) (list "dataset" "target" "actor" "recurring" "delay" "options"))))
    (loop for row in (data-table:rows targets)
          collect (cons (nth 2 row) (with-output-to-string (str)
                                       (cl-json:encode-json
                                        (spec:new-target (nth 0 row)
                                                         (nth 1 row)
                                                         (nth 2 row)
                                                         :options (nth 5 row)
                                                         :recurring (cond ((string= (string-downcase (nth 3 row)) "true") t)
                                                                          ((string= (string-downcase (nth 3 row)) "t") t)
                                                                          ((string= (nth 3 row) "1") t)
                                                                          ((string= (nth 3 row) "0") nil)
                                                                          ((string= (string-downcase (nth 3 row)) "nil") nil)
                                                                          ((string= (string-downcase (nth 3 row)) "false") nil))
                                                         :delay (nth 4 row)) str))))))

(defmethod import-targets-from-csv ((client star-client) file)
  (loop for target in (read-targets-csv file)
        do (new-target client (cdr target) (car target))))
#+end_src


*** TODO design map api
*** Submit documents
This route take input documents and inserts them into the rabbitmq =new-documents= queue.


#+begin_src lisp :tangle ./source/frontends/http-api.lisp :comments link
;; (setf (ningle:route *app* "/new/document/:dtype" :method :post)
;;       #'(lambda (params)

;;           (let ((dtype  (cdr (assoc :dtype params :test #'string=)))
;;                 (body (lack.request:request-content (ningle:context :request))))

;;             (star.rabbit:emit-document  "new-documents" "documents"  (format nil "documents.new.~a" dtype) body :properties (list (list :headers `("dtype" . ,dtype))))
;;             (format nil "documents.new.~a" dtype))))


(setf (ningle:route *app* "/new/document/:dtype" :method :post)
      #'(lambda (params)

          (let* ((dtype  (cdr (assoc :dtype params :test #'string=)))
                 (body (babel:octets-to-string  (lack.request:request-content (ningle:context :request)) :encoding :utf-8))
                 (routing-key (format nil "documents.new.~a" dtype)))
             (cl-rabbit:with-connection (conn)
              (let ((socket (cl-rabbit:tcp-socket-new conn)))
                (cl-rabbit:socket-open socket star:*rabbit-address* star:*rabbit-port*)
                (cl-rabbit:login-sasl-plain conn "/" star:*rabbit-user* star:*rabbit-password*)
                (cl-rabbit:with-channel (conn 1)
                  (cl-rabbit:basic-publish conn 1 :routing-key routing-key :exchange "documents"  :properties (list (cons :type dtype )) :body body))))
            (print "got new document")
            (force-output)
            body)))



#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (PARAMS)) {1001E3305B}>

**** example usage
#+begin_src http :comments none
POST http://0.0.0.0:5000/new/document/person

{"_id": "6y4q","dataset":"","dtype":"person", "version":"0.7.1","dateUpdated":1713387117,"dateAdded":1713387117,"fname":"Klaus","mname":"","lname":"Shwabb","bio":"","dob":"","race":"","region":"", "etype":"","eid":""}
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Thu, 09 May 2024 16:40:45 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: {"_id": "6y4q","dataset":"","dtype":"person", "version":"0.7.1","dateUpdated":1713387117,"dateAdded":1713387117,"fname":"Klaus","mname":"","lname":"Shwabb","bio":"","dob":"","race":"","region":"", "etype":"","eid":""}
**** api client submit-document
#+begin_src lisp :tangle ./source/api-client.lisp :results none :comments link
(defmethod submit-document ((client star-client) document document-type)
  "Create a new document"
  (api-request client (format nil "/new/document/~a" document-type) :method :post :content document))
#+end_src
*** TODO Get Documents

#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(setf (ningle:route *app* "/document/:id" :method :get)
      #'(lambda (params)

          (let ((document-id  (cdr (assoc :id params :test #'string=))))

            (anypool:with-connection (client *couchdb-pool*)
              (cl-couch:get-document client star:*couchdb-default-database* document-id)))))
#+end_src

**** example usage
#+begin_src http
GET 127.0.0.1:5000/document/test-agents1
#+end_src

#+RESULTS:
**** api-client get-document
#+begin_src lisp :tangle ./source/api-client.lisp :results none :comments link
(defmethod get-document ((client star-client) document-id)
  "Get the document by id."
  (api-request client (format nil "/documents/~a" document-id)))
#+end_src

*** Start webapp
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :comments link
                                        ;(couchdb-middleware *app*)
(defun start-http-api ()
  (clack:clackup *app* :address star:*http-api-address* :port star:*http-api-port*))
#+end_src

#+RESULTS:
: #S(CLACK.HANDLER::HANDLER
:    :SERVER :HUNCHENTOOT
:    :SWANK-PORT NIL
:    :ACCEPTOR #<BORDEAUX-THREADS-2:THREAD "clack-handler-hunchentoot" {10051132F3}>)


* Main Entry
** Cli arg parsing
i opt to use clingon for cli arg parsing.[fn:2]
#+begin_src lisp :tangle ./source/main.lisp :results none :coments link
(in-package :starintel-gserver)
(defun server/options ()
  (list
   (clingon:make-option
    :string
    :description "Path to init file"
    :short-name #\i
    :long-name "init"
    :initial-value "./init.lisp"
    :env-vars '("STAR_SERVER_INIT_FILE")
    :key :init-value)
   (clingon:make-option
    :boolean
    :description "Enable Remote debugging"
    :short-name #\d
    :long-name "debugger"
    :key :debugger)))


#+end_src
** Server command handler
#+begin_src lisp :tangle ./source/main.lisp :results none :comments link


;; (defun server/handler (cmd))
  ;; (let ((debugger (clingon:getopt cmd :debugger))
  ;;       (init-file (clingon:getopt cmd :init-value)))
  ;;   (when debugger
  ;;     (slynk:create-server :port 50006 :dont-close t))
  ;;   (load init-file :if-does-not-exist :create)
  ;;   (sento-user::start-actors)
  ;;   (star.rabbit::start-rabbit-document-thread :host *rabbit-address* :port *rabbit-port*)
  ;;   (star.rabbit::start-rabbit-targets-thread :host *rabbit-address* :port *rabbit-port*)
  ;;   (init-db)
  ;;   (star.frontends.http-api::start-http-api)
  ;;   (sento-user::start-target-loader))


;; (defun server/command ()
;;   "A command to greet someone"
;;   (clingon:make-command
;;    :name "start"
;;    :description "start the server"
;;    :version "0.1.0"
;;    :authors '("nsaspy <nsaspy@airmail.cc>")
;;    :license "GPL v3"
;;    :options (server/options)
;;    :handler #'server/handler))


(defun main ()
  (let ((init-file "init.lisp"))
    (init-db)
    (sento-user::start-actors)
    (star.rabbit::start-rabbit-document-thread :host *rabbit-address* :port *rabbit-port*)
    (star.rabbit::start-rabbit-targets-thread :host *rabbit-address* :port *rabbit-port*)
    (load init-file :if-does-not-exist :create)
    (star.frontends.http-api::start-http-api)
    (sleep 5))
    ;(bt:make-thread #'sento-user::start-target-loader :name "*target-loader*"))
  (loop do (sleep 1)))
#+end_src

* Tasks
All tasks can have a very general headline, but the NAME must be topic.possibpe-sub-topic.thing scheme.
This section is for [[https://github.com/TxGVNN/project-tasks][project-tasks]].

#+Name:  open.rabbitmq
#+begin_src shell :async :results none
xdg-open http://127.0.0.1:15672/#/
#+end_src

#+Name: open couchdb
#+begin_src shell :async :results none
xdg-open http://127.0.0.1:5983/_utils
#+end_src



** Updates
#+Name: update.flake
#+begin_src shell :async :results output replace
nix flake update
direnv reload .
#+end_src

#+RESULTS: update.flake

#+RESULTS: Update flake
** Docker
*** Run a rabbitmq instance
#+Name: docker.run.rabbitmq
#+begin_src shell :async :results output replace :tangle start.sh
docker run -d -p 5672:5672 -p 15672:15672 -e RABBITMQ_USER=user -e RABBITMQ_PASS=password   rabbitmq:3.13.1-management
#+end_src

#+RESULTS: docker.run.rabbitmq
: 136e9a2898d2fd0d89d9d86ab88e67edeeb8167f2e979b153105256bd2a3726b

#+RESULTS: Start Rabbitmq

*** Kill Rabbitmq
#+Name: docker.kill.rabbitmq
#+begin_src shell :async :results output replace
docker kill rabbitmq_org_dev
#+end_src

#+RESULTS: docker.kill.rabbitmq
: rabbitmq_org_dev


*** List Docker PS
#+Name: docker.ps
#+begin_src shell :async :results output replace
docker ps
#+end_src
** Build
#+Name: build.server
#+begin_src sh :async :results output replace
make build
#+end_src

#+RESULTS: build.server
: b3bc5811a0bf8b118f78669339185d13

* Footnotes
[fn:2] https://github.com/dnaeon/clingon

[fn:1] https://gist.github.com/dnaeon/3a3f86dea1096db5a9231d1f56a565e2
