#+title: Source
#+STARTUP: show2levels

* Ideas
The main idea of this project is to have a single, closed source api interface that will be the SINGLE source for starintel data

** TODO allow it to be extended [0/3]
*** TODO Simple data transform system
*** TODO Simple map-reduce over rabbitmq
*** IDEA Move the config vars into a container?



* Packaging

Given the org-mode file

** Makefile
#+begin_src makefile :tangle Makefile :comments link
##
# Starintel Gserver
#
# @file
# @version 0.1

LISP ?= sbcl

all: test

run:
	$(LISP) --load run.lisp

build:
	$(LISP)	--non-interactive \
		--load source/starintel-gserver.asd \
		--eval '(ql:quickload :starintel-gserver)' \
		--eval "(sb-ext:save-lisp-and-die \"star-server\" :toplevel 'starintel-gserver::main :executable t :compression t)"
install:
	cp star-server /usr/local/bin

clean:
	rm -f ./star-server
#+end_src

** Nix

#+begin_src nix :tangle flake.nix :comments link
{
  description = "Starintel API server that routes the data through msg queues.";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }:
    let
      pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in
    {
      devShell.x86_64-linux =
        pkgs.mkShell {
          buildInputs = with pkgs; [
            pkg-config
            sbcl
            openssl
            rabbitmq-c
            libffi
            sqlite
          ];
          shellHook = ''
            export LD_LIBRARY_PATH=${pkgs.lib.makeLibraryPath([pkgs.openssl pkgs.rabbitmq-c pkgs.libffi pkgs.sqlite])}
          '';
        };
    };
}

#+end_src

Here is
#+begin_src sh
use flake
# When we run make in prod it will gen defaults
# Debug is just for testing
export BUILD_MODE="DEV"
use flake
export COUCHDB_HOST="127.0.0.1"
export COUCHDB_PORT=5984
export COUCHDB_SCHEME="http"
export COUCHDB_USER="admin"
export COUCHDB_PASSWORD="password"
export COUCHDB_DATABASE="starintel"

#+end_src

#+RESULTS:
: CONTAINER ID   IMAGE                             COMMAND                  CREATED        STATUS      PORTS                                                                                                      NAMES
: d421e7dea3a1   zhaowde/rotating-tor-http-proxy   "/bin/sh -c /start.sh"   3 months ago   Up 8 days   3128/tcp, 0.0.0.0:1444->1444/tcp, :::1444->1444/tcp, 4444/tcp, 0.0.0.0:3128->3218/tcp, :::3128->3218/tcp   docker-rotating-tor-1

** Lisp stuff
*** ASDF
Here is the system def for it.
#+begin_src lisp :tangle source/starintel-gserver.asd :comments link
(asdf:defsystem :starintel-gserver
  :version      "0.1.0"
  :description  "hackable/moddable starintel acess api."
  :author       "nsaspy@airmail.cc"
  :license      "GPL v3"
  :serial t
  :build-operation program-op
  :build-pathname "foobar-command" ;; shell name
  :entry-point "foobar::start-foobar" ;; thunk
  :components   (
                 (:file "package")
                 (:file "gserver-settings" :depends-on ("package"))
                 (:file "init" :depends-on ("gserver-settings"))
                 (:file "actors" :depends-on ("gserver-settings"))
                 (:file "rabbit" :depends-on ("actors" "gserver-settings"))
                 (:file "frontends/http-api" :depends-on ("gserver-settings"))
                 (:file "main" :depends-on ("actors" "rabbit" "package" "gserver-settings" "frontends/http-api")))

  :depends-on   (#:starintel #:cl-couch #:serapeum  #:alexandria #:cl-rabbit #:sento #:babel #:cl-json :uuid #:anypool
                             #:clack #:ningle #:hunchentoot #:clingon #:slynk))
 #+end_src
*** Namespace setup
I prefer to have my namespace done in a somewhat hierarchical style.

So lets say you want to make a http frontend api, there is going to be the namespace for it:
- star.frontends.http

And a database namespace would be:
- star.database.<database-type-or-name>


#+begin_src lisp :tangle ./source/frontends/package.lisp :results none :comments link
(uiop:define-package   :star.frontend.http-api
  (:nicknames :frontend.http-api)
  (:use       :cl)
  (:documentation "doc"))
#+end_src

gserver namespace, general top level.

#+begin_src lisp :tangle ./source/package.lisp :comments link
(uiop:define-package   :starintel-gserver
  (:nicknames :star)
  (:use       :cl)
  (:export
   #:init-db
   #:*rabbit-password*
   #:*rabbit-user*
   #:*rabbit-port*
   #:*rabbit-address*
   #:*http-scheme*
   #:*http-key-file*
   #:*http-cert-file*
   #:*http-api-base-path*
   #:*http-api-port*
   #:*http-api-address*
   #:*couchdb-default-database*
   #:*couchdb-host*
   #:*couchdb-port*
   #:*couchdb-user*
   #:*couchdb-password*
   #:*couchdb-scheme*))
#+end_src

#+RESULTS:
: #<PACKAGE "STARINTEL-GSERVER">

#+begin_src lisp :tangle ./source/package.lisp :results none :comments link
(uiop:define-package   :starintel-gserver.rabbit
  (:nicknames :star.rabbit)
  (:use       :cl)
  (:documentation "Rabitmq namespace")
  (:export
   #:start-rabbit-document-thread
   #:with-rabbit-send
   #:with-rabbit-recv
   #:emit-document))
#+end_src

#+begin_src lisp :tangle ./source/package.lisp :results none :comments link
(uiop:define-package   :starintel-gserver-http-api
  (:nicknames :star.frontends.http-api)
  (:use       :cl)
  (:documentation "doc"))
#+end_src
** Docker
#+begin_src Dockerfile :tangle ./Dockerfile :comments none
FROM fukamachi/sbcl:latest as build
# Install required packages
RUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt set -x; \
    apt-get update && \
    apt-get install -y \
    make \
    libffi-dev \
    pkg-config \
    librabbitmq-dev \
    build-essential

# Create a user and set up working directory
RUN ros setup

# Copy dependencies
COPY . /root/

# Set up symbolic links using ln
RUN ln -s /root/deps/ /root/common-lisp
WORKDIR /root/
RUN make build
RUN make install
FROM build as star-router
ENV BUILD_MODE="DEV" \
    COUCHDB_HOST="127.0.0.1" \
    COUCHDB_PORT=5984 \
    COUCHDB_SCHEME="http" \
    COUCHDB_USER="admin" \
    COUCHDB_PASSWORD="password" \
    COUCHDB_DATABASE="starintel" \
    HTTP_API_LISTEN_ADDRESS="localhost" \
    RABBITMQ_HOST="rabbitmq" \
    RABBITMQ_PORT=5672
# Expose port 5000
EXPOSE 5000

# Entrypoint to start the server
ENTRYPOINT ./star-server
CMD [./star-server]
#+end_src
** TODO Kali/parrot
#+Name: Install docker
#+begin_src shell :async :results output replace :tangle parrot_kali.sh :comments link
install_docker() {
    sudo apt update
    sudo apt install -y apt-transport-https ca-certificates curl software-properties-common
    curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt update
    sudo apt install -y docker-ce docker-ce-cli containerd.io
    sudo apt install -y docker-compose
    sudo usermod -aG docker $USER

}


install_docker

#+end_src

* Settings
#+begin_src lisp :tangle ./source/gserver-settings.lisp :results none :comments link
(in-package :star)
(defparameter *couchdb-host* (or (uiop:getenv "COUCHDB_HOST") "127.0.0.1") "The Couchdb host to use.")
(defparameter *couchdb-port* 5984 "The Couchdb port to use.")
(defparameter *couchdb-default-database* "starintel" "the default database name to use.")
(defparameter *couchdb-target-database* "starintel-targets" "the database to be used for target data.")
(defparameter *couchdb-scheme* "http" "what http scheme to use. set to http or https")
(defparameter *couchdb-user* (or (uiop:getenv "COUCHDB_USER") "admin") "couchdb user")
(defparameter *couchdb-password* (or (uiop:getenv "COUCHDB_PASSWORD") "password") "couchdb user password")
#+end_src
** Frontends
*** Http Settings
This section contains only settings related to http frontend

**** Listen Address

#+begin_src lisp :tangle ./source/gserver-settings.lisp :comments link
(defparameter *http-api-address* (or (uiop:getenv "HTTP_API_LISTEN_ADDRESS") "localhost") "the listen address")
(defparameter *http-api-port* 5000  "the port the api server listen on")
(defparameter *http-api-base-path* "/api" "the base url to use for the api endpoint")
(defparameter *http-cert-file* nil "path to the http api cert providing https")
(defparameter *http-key-file* nil "path to the http cert providing https")
(defparameter *http-scheme* 'http "use https or not.")
#+end_src
** Rabbit mq settings
*** Authentication
#+begin_src lisp :tangle ./source/gserver-settings.lisp :comments link
(defparameter *rabbit-address* (or (uiop:getenv "RABBITMQ_ADDRESS") "localhost") "The address rabbitmq is running on.")
(defparameter *rabbit-port* 5672 "The port that rabbitmq is listening on.")
(defparameter *rabbit-user* "guest" "the username for rabbimq")
(defparameter *rabbit-password* "guest" "the password for the rabbitmq user.")

(eval-when (:execute)
  )
#+end_src

#+RESULTS:
: *RABBIT-PASSWORD*


* Actors

** Actor system setup
The sen to package expects us to be in the sento user package.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(in-package :sento-user)
(defparameter *sys* nil "the main actor system")
(defun start-actor-system ()
  (setf *sys* (make-actor-system))
)
 #+end_src

** Eventing

Sento supports events but I can only use a symbol or a simple string. it supports matching by class types too.

This allows actors to filter out messages by topic.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defclass message-event ()
  ((topic :initarg :topic :initform (error "Topic for event stream is required.") :reader message-topic)
   (data :initarg :data :type string :initform "" :reader message-data))
  (:documentation "A basic class that holds message event topic and data"))
#+end_src

The interface for matching topics is ~topic-match-p~.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defgeneric topic-match-p (msg topic)
  (:documentation "generic interface that matches if a msg matches the subbed topic."))

(defmethod topic-match-p ((msg message-event) topic)
  "Return T if topic matches msg's topic"
  (string= topic (string-downcase (message-topic msg))))


(defun new-event (&key topic data (eventstream *sys*))
  "Create an publish a new message-event.
    This is a simple wrapper around the publish from sento."
  (publish eventstream (make-instance 'message-event :topic topic :data data)))


(defmacro with-topics ((&key msg topics) &body body)
  "A macro that will check if MSG topic "
  `(loop for topic in ,topics

         if (topic-match-p ,msg topic)
           do (progn ,@body)))
#+end_src

Here is a simple example of an actor that works with person objects.
#+begin_src lisp
(ac:actor-of *sys* :name "personator"
                   :init (lambda (self)
                           (ev:subscribe self self 'message-event))
                   :receive (lambda (msg)
                              (with-topics (:msg msg :topics '("New-Person"))
                                (format nil "~a" (starintel:doc-id msg)))))

#+end_src
** API
Actors need to interact with external services like couchdb.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defun make-api-msg (sender data)
    (cons data sender))
#+end_src

*** Couchdb
**** Client Pooling
Couchdb is the main database I have used for many projects, I am using [[https://github.com/lost-rob0t/cl-couch][cl-couch]] for the database client. It doesnt use async so I need to setup a resource pools, for that I use anypool.


#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") 5984 :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME")))))
                                    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src

start--pool-monitoring is used for checking the total active count from the couchdb client pool.
it is only used internally for debugging.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defvar *my-thread* nil)

(defun start--pool-monitoring ()
  (setf *my-thread*
        (bt:make-thread
         (lambda ()
           (loop
             do (progn (format t "Active count: ~a, Idle count: ~a~%"
                               (anypool:pool-active-count *couchdb-pool*)
                               (anypool:pool-idle-count *couchdb-pool*))
                       (force-output)
                       (sleep 1))
             finally (bt:thread-yield))))))

(defun stop--pool-monitoring ()
  (when *my-thread*
    (bt:destroy-thread *my-thread*)
    (setf *my-thread* nil)))

#+end_src

**** couchdb-insert actors
This actor will insert documents into couchdb.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-inserts* nil)
(defun start-couchdb-inserts ()
  (setf *couchdb-inserts* (ac:actor-of *sys*
                                              :name "*couchdb-inserts*"
                                              :receive (lambda (msg)
                                                         (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
                                                               (pool *couchdb-pool*))

                                                           (with-context (*sys* :pinned)
                                                             (task-start
                                                              (lambda ()
                                                                (anypool:with-connection (client pool)
                                                                  (cl-couch:create-document client destination-db (cdr msg) :batch "normal"))))))))))
#+end_src
**** couchdb-get actor
This actor is to be used by other actors wishing to interact with the couchdb database.
The message to be sent MUST be ~(cons sender data)~.
#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-gets* nil "The Couchdb actor responsible for handling document gets.")

(defun start-couchdb-gets ()
  (setf *couchdb-gets* (ac:actor-of *sys* :name "*couchdb-gets*"
                                          :receive (lambda (msg)
                                                     (let ((pool *couchdb-pool*)
                                                           (db (uiop:getenv "COUCHDB_DATABASE")))
                                                       (with-context (*sys*)
                                                         (anypool:with-connection (client pool)
                                                           (task-async (lambda ()
                                                                         (handler-case
                                                                             (cl-couch:get-document client db (car msg))
                                                                           (dex:http-request-not-found (e) nil)
                                                                           (dex:http-request-unauthorized (e) nil)))
                                                                       :on-complete-fun (lambda (doc)
                                                                                          (reply doc (cdr msg)))))))))))

#+end_src

**** TODO finish bulk insert actor

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
;; (defparameter *couchdb-bulk-insert* (ac:actor-of *sys*
;;                                                  :name "*couchdb-bulk-insert*"
;;                                                  :receive (lambda (msg)
;;                                                             (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
;;                                                                   (pool *couchdb-pool*))
;;                                                               (anypool:with-connection (client pool)
;;                                                                 (cl-couch:bulk-create-documents client destination-db msg :batch "normal"))))))



#+end_src


#+end_src
** IDEA Document Handler
#+begin_src lisp
(defun start-document-handler-actor ()
  (defparameter *document-handler* (ac:actor-of *sys*)))


#+end_src
** STRT Create Target scheduling actor
It will be an actor that kicks off recurring jobs, will require spec change to include "recurring" field.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *target-timer* nil)
(defun start-target-timer ()
   (setf *target-timer* (wt:make-wheel-timer)))
#+end_src

*** Target Actor

#+begin_src lisp :tangle ./source/actors.lisp :results  none :comment link
(defparameter *target-actor* nil)

;; (defun start-target-actor (system)
;;   (setf *target-actor* (ac:actor-of system
;;                                     :name "*target-actor*"
;;                                     :receive (lambda (msg)
;;                                                (with-context (system)
;;                                                  (let ((resp (task-async (lambda ()
;;                                                                            (let ((resp (cl-couch:get-view))))))))))))))
#+end_src



** actor entry point

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defun start-actors ()
  (start-actor-system)
  (start-target-timer)
  (start-couchdb-inserts))
#+end_src

In order to compile the actor system must be stop

* RabbitMQ

** Macro Wrappers
The [[https://github.com/lokedhs/cl-rabbit][cl-rabbit]] lib is a bit lower level then I want to work with so I will create a basic macros to make the interface nicer

The newer sento benchmarks are showing its VERY performent now, so we will actually just create a agent, then use the sento actor system.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(in-package :star.rabbit)

(defmacro with-rabbit-recv ((queue-name exchange-name exchange-type routing-key &key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)
         (cl-rabbit:exchange-declare conn 1 ,exchange-name ,exchange-type)

         (cl-rabbit:queue-declare conn 1 :queue ,queue-name :durable ,durable :auto-delete ,auto-delete :exclusive ,exclusive)
         (cl-rabbit:queue-bind conn 1 :queue ,queue-name :exchange ,exchange-name :routing-key ,routing-key)

         (cl-rabbit:basic-consume conn 1 ,queue-name)
         (loop
           for msg = (cl-rabbit:envelope/message (cl-rabbit:consume-message conn))
           do ,@body)))))

(defmacro with-rabbit-send ((queue-name exchange-name exchange-type routing-key &key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)

         ,@body))))

(defun emit-document (queue-name exchange routing-key body &key (properties nil)
                                                             (immediate nil)
                                                             (mandatory nil)
                                                             (port star:*rabbit-port*)
                                                             (host star:*rabbit-address*)
                                                             (username star:*rabbit-user*)
                                                             (password star:*rabbit-password*)
                                                             (vhost "/"))
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket host port)
      (when (and username password)
        (cl-rabbit:login-sasl-plain conn vhost username password))
      (cl-rabbit:with-channel (conn 1)

        (cl-rabbit:queue-bind conn 1 :queue queue-name :exchange exchange :routing-key routing-key)
        (cl-rabbit:basic-publish conn 1 :routing-key routing-key :exchange exchange :mandatory mandatory :immediate immediate :properties properties :body body)))))
#+end_src
** Handle New Document consumers

Take a rabbimq message and parse it.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun message->string (msg &key (encoding :utf-8))
  "take a rabbitmq message and return the boddy as a string"
  (babel:octets-to-string (cl-rabbit:message/body msg) :encoding encoding))

                                        ;TODO
(defun message->object (msg)
  "Tale a rabbbitmq message and return a object. The object that will be returned depends on the message property 'dtype`.")

(defun handle-new-document (msg)
  "Handles any new incoming documents and sends it to the appropriate actors."
  (let* ((props (cl-rabbit:message/properties msg))
         (headers (assoc :HEADERS props :test #'equal))
         (dtype (when headers (cdr (assoc "dtype" (cdr headers) :test #'equal))))
         (body (message->string msg)))
    (cons dtype body)))
#+end_src

Start the rabbit new document monitoring thread.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun start-rabbit-document-thread (&key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*))
  (loop for i from 0 to 4
        do (bt:make-thread
            (lambda ()
              (with-rabbit-recv ("injest" "documents" "topic" "documents.new.*")
                (let (
                      (data (handle-new-document msg)))
                  (sento-user::ask sento-user::*couchdb-inserts* data))))
            ;; (sento-user::publish sento-user::*sys* (sento-user::new-event :topic (string-downcase (car data)) :data (cdr data)))


            :name "*new-documents*")))
#+end_src
** quick test functions

These functions are for quick debugging of the rabbitmq.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun test-make-doc ()

  (with-output-to-string (str) (cl-json:encode-json (starintel:set-meta (make-instance  'starintel:person :id (uuid:make-v4-uuid) :lname "doe" :fname "john") "starintel") str)))

(defun test-send ()
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket "localhost" 5672)
      (cl-rabbit:login-sasl-plain conn "/" "guest" "guest")
      (cl-rabbit:with-channel (conn 1)
        (cl-rabbit:basic-publish conn 1
                                 :exchange "documents"
                                 :routing-key "documents.new.Person"
                                 :body (test-make-doc)
                                 :properties '((:headers . (("dtype"  . "Person")))))))))
#+end_src
** Map Reduce
*** Ideas
Last updated: <2024-04-18 Thu>
**** Basic Data transform
Map reduce will allow for a simple, realtime data enrichment system.

An example use would be creating and comparing fingerprints for documents.
***** transformer context
#+begin_src lisp :tangle ./source/transform.lisp :results none :comments link
((defclass transformer ()
   ((socket :initarg :socket :accessor transformer-socket :allocation :instance)
    (channel))
   (:documentation "doc")))
#+end_src
* Databases
** Couchdb
*** Views
**** Data View
Analytics views county documents by their type.

#+begin_src json :tangle ./source/views/data.json
{"_id":"_design/data","views":{"count_by_dtype":{"map":"function(doc) {\n  if (doc.dtype && doc.dtype !== \"Relation\") {\n    emit(doc.dtype, 1);\n  }\n}","reduce":"_count"},"dataset_size":{"reduce":"_count","map":"function (doc) {\n  emit(doc.dataset, 1);\n  \n}"},"total":{"reduce":"_sum","map":"function (doc) {\n  emit(null, 1);\n}"}},"language":"javascript"}
#+end_src

**** Relations View
Very basic graph index, simply way of getting neighbors

#+begin_src json :tangle ./source/views/relations.json
{"_id":"_design/relations","views":{"outgoing-count":{"reduce":"_count","map":"function (doc) {\n  if (doc.dtype === \"Relation\") {\n    emit(doc.source, 1);\n  }\n}"},"incoming-count":{"reduce":"_count","map":"function (doc) {\n  if (doc.dtype === \"Relation\") {\n    emit(doc.target, 1);\n  }\n}"},"edges":{"map":"function (doc) {\n  if(doc.dtype===\"Relation\"){\n  emit(doc.target, {\"_id\": doc._id, \"note\": doc.note});\n}}","reduce":"function(keys, values, rereduce) {\n  var results = [];\n  if (!rereduce) {\n    values.forEach(function(value) {\n      if (results.indexOf(value) === -1) {\n        results.push(value);\n      }\n    });\n  } else {\n    values.forEach(function(arr) {\n      arr.forEach(function(value) {\n        if (results.indexOf(value) === -1) {\n          results.push(value);\n        }\n      });\n    });\n  }\n  return results;\n}"},"neighbors":{"reduce":"function(keys, values, rereduce) {\n  var results = [];\n  if (!rereduce) {\n    values.forEach(function(value) {\n      if (results.indexOf(value) === -1) {\n        results.push(value);\n      }\n    });\n  } else {\n    values.forEach(function(arr) {\n      arr.forEach(function(value) {\n        if (results.indexOf(value) === -1) {\n          results.push(value);\n        }\n      });\n    });\n  }\n  return results;\n}","map":"function (doc) {\n  if(doc.dtype===\"Relation\"){\n  emit(doc.source, doc.target);  \n}}"},"edge-note":{"map":"function (doc) {\n  if(doc.dtype == \"Relation\"){\n  emit(doc.note, null);\n}}","reduce":"_count"}},"language":"javascript"}

#+end_src

**** Search View
Full Text search index

#+begin_src json :tangle ./source/views/search.json
{"_id":"_design/search","views":{},"language":"javascript","indexes":{"fts":{"analyzer":{"name":"perfield","default":"standard","fields":{}},"index":"function(doc) { \n  index('dataset', doc.dataset, {\"store\": \"yes\", \"field\": \"dataset\"});\n  index('date_added', doc.date_added, {\"store\": \"yes\", \"field\": \"date_added\"});\n  index('date_updated', doc.date_updated, {\"store\": \"yes\", \"field\": \"date_updated\"});\n  index('dtype', doc.dtype, {\"store\": \"yes\", \"field\": \"dtype\"});\n  if (doc.dtype == \"Entity\") {\n        var total = doc.etype + \" \" + doc.eid;\n        index('etype', doc.etype, {\"store\": \"yes\", \"field\": \"etype\"});\n        index('eid', doc.eid, {\"store\": \"yes\", \"field\": \"eid\"});\n        if (doc.dataset) {\n            index('dataset', doc.dataset, {\"store\": \"yes\", \"field\": \"dataset\"});\n        }\n        if (doc.date_added) {\n            index('date_added', doc.date_added, {\"store\": \"yes\", \"field\": \"date_added\"});\n        }\n        if (doc.date_updated) {\n            index('date_updated', doc.date_updated, {\"store\": \"yes\", \"field\": \"date_updated\"});\n        }\n    }\n    if (doc.dtype == \"Org\") {\n        var total = doc.reg + \" \" + doc.country + \" \" + doc.name + \" \" + doc.website + \" \" + doc.bio;\n        index('reg', doc.reg, {\"store\": \"yes\", \"field\": \"reg\"});\n        index('country', doc.country, {\"store\": \"yes\", \"field\": \"country\"});\n        index('name', doc.name, {\"store\": \"yes\", \"field\": \"name\"});\n        index('website', doc.website, {\"store\": \"yes\", \"field\": \"website\"});\n        index('bio', doc.bio, {\"store\": \"yes\", \"field\": \"bio\"});\n    }\n    if (doc.dtype == \"Person\") {\n        var total = doc.fname + \" \" + doc.mname + \" \" + doc.lname + \" \" + doc.bio + \" \" + doc.dob + \" \" + doc.gender + \" \" + doc.race + \" \" + doc.region + \" \" + JSON.stringify(doc.misc);\n        index('fname', doc.fname, {\"store\": \"yes\", \"field\": \"fname\"});\n        index('mname', doc.mname, {\"store\": \"yes\", \"field\": \"mname\"});\n        index('lname', doc.lname, {\"store\": \"yes\", \"field\": \"lname\"});\n        index('bio', doc.bio, {\"store\": \"yes\", \"field\": \"bio\"});\n        index('dob', doc.dob, {\"store\": \"yes\", \"field\": \"dob\"});\n        index('gender', doc.gender, {\"store\": \"yes\", \"field\": \"gender\"});\n        index('race', doc.race, {\"store\": \"yes\", \"field\": \"race\"});\n        index('region', doc.region, {\"store\": \"yes\", \"field\": \"region\"});\n        if (doc.misc) {\n            index('misc', JSON.stringify(doc.misc), {\"store\": \"yes\", \"field\": \"misc\"});\n        }\n    }\n        if (doc.dtype == \"Message\") {\n        var total = doc.message + \" \" + doc.platform + \" \" + doc.user + \" \" + doc.message_id + \" \" + doc.reply_to + \" \" + doc.group + \" \" + doc.channel + \" \" + JSON.stringify(doc.mentions);\n        index('message', doc.message, {\"store\": \"yes\", \"field\": \"message\"});\n        index('platform', doc.platform, {\"store\": \"yes\", \"field\": \"platform\"});\n        index('user', doc.user, {\"store\": \"yes\", \"field\": \"user\"});\n        index('message_id', doc.message_id, {\"store\": \"yes\", \"field\": \"message_id\"});\n        index('reply_to', doc.reply_to, {\"store\": \"yes\", \"field\": \"reply_to\"});\n        index('group', doc.group, {\"store\": \"yes\", \"field\": \"group\"});\n        index('channel', doc.channel, {\"store\": \"yes\", \"field\": \"channel\"});\n        if (doc.mentions) {\n            index('mentions', JSON.stringify(doc.mentions), {\"store\": \"yes\", \"field\": \"mentions\"});\n        }\n    }\n    if (doc.dtype == \"SocialMPost\") {\n        var total = doc.content + \" \" + doc.user + \" \" + JSON.stringify(doc.replies) + \" \" + JSON.stringify(doc.media) + \" \" + doc.replyCount + \" \" + doc.repostCount + \" \" + doc.url + \" \" + JSON.stringify(doc.links) + \" \" + JSON.stringify(doc.tags) + \" \" + doc.title + \" \" + doc.group + \" \" + doc.replyTo;\n        index('content', doc.content, {\"store\": \"yes\", \"field\": \"content\"});\n        index('user', doc.user, {\"store\": \"yes\", \"field\": \"user\"});\n        if (doc.replies) {\n            index('replies', JSON.stringify(doc.replies), {\"store\": \"yes\", \"field\": \"replies\"});\n        }\n        if (doc.media) {\n            index('media', JSON.stringify(doc.media), {\"store\": \"yes\", \"field\": \"media\"});\n        }\n        index('replyCount', doc.replyCount, {\"store\": \"yes\", \"field\": \"replyCount\"});\n        index('repostCount', doc.repostCount, {\"store\": \"yes\", \"field\": \"repostCount\"});\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n        if (doc.links) {\n            index('links', JSON.stringify(doc.links), {\"store\": \"yes\", \"field\": \"links\"});\n        }\n        if (doc.tags) {\n            index('tags', JSON.stringify(doc.tags), {\"store\": \"yes\", \"field\": \"tags\"});\n        }\n        index('title', doc.title, {\"store\": \"yes\", \"field\": \"title\"});\n        index('group', doc.group, {\"store\": \"yes\", \"field\": \"group\"});\n        index('replyTo', doc.replyTo, {\"store\": \"yes\", \"field\": \"replyTo\"});\n    }\n    if (doc.dtype == \"Breach\") {\n        var total = doc.total + \" \" + doc.description + \" \" + doc.url;\n        index('total', doc.total, {\"store\": \"yes\", \"field\": \"total\"});\n        index('description', doc.description, {\"store\": \"yes\", \"field\": \"description\"});\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n    }\n    if (doc.dtype == \"Email\") {\n        var total = doc.user + \" \" + doc.domain + \" \" + doc.password;\n        index('user', doc.user, {\"store\": \"yes\", \"field\": \"user\"});\n        index('domain', doc.domain, {\"store\": \"yes\", \"field\": \"domain\"});\n        index('password', doc.password, {\"store\": \"yes\", \"field\": \"password\"});\n    }\n    if (doc.dtype == \"EmailMessage\") {\n        var total = doc.body + \" \" + doc.subject + \" \" + doc.to + \" \" + doc.fromF + \" \" + doc.headers + \" \" + JSON.stringify(doc.cc) + \" \" + JSON.stringify(doc.bcc);\n        index('body', doc.body, {\"store\": \"yes\", \"field\": \"body\"});\n        index('subject', doc.subject, {\"store\": \"yes\", \"field\": \"subject\"});\n        index('to', doc.to, {\"store\": \"yes\", \"field\": \"to\"});\n        index('fromF', doc.fromF, {\"store\": \"yes\", \"field\": \"fromF\"});\n        if (doc.cc) {\n            index('cc', JSON.stringify(doc.cc), {\"store\": \"yes\", \"field\": \"cc\"});\n        }\n        if (doc.bcc) {\n            index('bcc', JSON.stringify(doc.bcc), {\"store\": \"yes\", \"field\": \"bcc\"});\n        }\n    }\n    if (doc.dtype == \"User\") {\n        var total = doc.url + \" \" + doc.name + \" \" + doc.platform + \" \" + JSON.stringify(doc.misc) + \" \" + doc.bio;\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n        index('name', doc.name, {\"store\": \"yes\", \"field\": \"name\"});\n        index('platform', doc.platform, {\"store\": \"yes\", \"field\": \"platform\"});\n        if (doc.misc) {\n            index('misc', JSON.stringify(doc.misc), {\"store\": \"yes\", \"field\": \"misc\"});\n        }\n        index('bio', doc.bio, {\"store\": \"yes\", \"field\": \"bio\"});\n    }\n      if (doc.dtype == \"Phone\") {\n        var total = doc.number + \" \" + doc.carrier + \" \" + doc.status + \" \" + doc.phone_type;\n        index('number', doc.number, {\"store\": \"yes\", \"field\": \"number\"});\n        index('carrier', doc.carrier, {\"store\": \"yes\", \"field\": \"carrier\"});\n        index('phone_type', doc.phone_type, {\"store\": \"yes\", \"field\": \"phone_type\"});\n    }\n    \n    if (doc.dtype == \"Web\") {\n        var total = doc.source;\n        index('source', doc.source, {\"store\": \"yes\", \"field\": \"source\"});\n    }\n    if (doc.dtype == \"Domain\") {\n        var total = doc.recordType + \" \" + doc.record + \" \" + doc.ip;\n        index('recordType', doc.recordType, {\"store\": \"yes\", \"field\": \"recordType\"});\n        index('record', doc.record, {\"store\": \"yes\", \"field\": \"record\"});\n        index('ip', doc.ip, {\"store\": \"yes\", \"field\": \"ip\"});\n    }\n    if (doc.dtype == \"Network\") {\n        var total = doc.org + \" \" + doc.asn.number + \" \" + doc.asn.subnet;\n        index('org', doc.org, {\"store\": \"yes\", \"field\": \"org\"});\n        index('asnNumber', doc.asn.number, {\"store\": \"yes\", \"field\": \"asnNumber\"});\n        index('subnet', doc.asn.subnet, {\"store\": \"yes\", \"field\": \"subnet\"});\n    }\n    if (doc.dtype == \"Host\") {\n        var total = doc.hostname + \" \" + doc.ip + \" \" + JSON.stringify(doc.ports) + \" \" + doc.os;\n        index('hostname', doc.hostname, {\"store\": \"yes\", \"field\": \"hostname\"});\n        index('ip', doc.ip, {\"store\": \"yes\", \"field\": \"ip\"});\n        if (doc.ports) {\n            index('ports', JSON.stringify(doc.ports), {\"store\": \"yes\", \"field\": \"ports\"});\n        }\n        index('os', doc.os, {\"store\": \"yes\", \"field\": \"os\"});\n    }\n    if (doc.dtype == \"Url\") {\n        var total = doc.url + \" \" + doc.content;\n        index('url', doc.url, {\"store\": \"yes\", \"field\": \"url\"});\n        index('content', doc.content, {\"store\": \"yes\", \"field\": \"content\"});\n    }\n\n    \n    \n}"}}}
#+end_src
**** Time View

Get documents based on time.

#+begin_src json :tangle ./source/views/time.json
{"_id":"_design/time","language":"javascript","views":{"dateAdded":{"map":"function (doc) {\n  emit(doc.date_added, doc._id);\n}","reduce":"_count"},"timeline":{"map":"function (doc) {\n  emit(doc._id, doc.date_added);\n}"}}}
#+end_src

**** Targets View

Get documents based on time.

#+begin_src json :tangle ./source/views/targets.json
{"_id": "_design/targets", "views": { "actor-targets": {"map": "function (doc) {\n  emit(doc.actor, doc.target);\n}"},"actor-target-count": {"reduce": "_count","map": "function (doc) {\n  emit(doc.actor, 1);\n}"},"target-count": {"reduce": "_sum","map": "function (doc) {\n  emit(doc.target, 1);\n}"}},"language": "javascript"}
#+end_src

*** Init database for first time
#+begin_src lisp :tangle ./source/init.lisp :results none
(in-package :starintel-gserver)

(defun init-views (client database)
  (let ((files (uiop:directory-files (uiop:merge-pathnames* "views/" (asdf:system-source-directory :starintel-gserver)))))
    (loop for file in files
          for jdata = (with-open-file (str file)
                        (format nil "~a~%" (read-line str)))
          do (cl-couch:create-document client database jdata))))

(defun init-db ()
  "Create the database, and all map-reduce views with it."
  (let* ((client (cl-couch:new-couchdb *couchdb-host* *couchdb-port* :scheme (string-downcase "http")))
         (database *couchdb-default-database*))
    (cl-couch:password-auth client *couchdb-user* *couchdb-password*)
    (handler-case (cl-couch:get-database client database)
      (dexador:http-request-not-found () (cl-couch:create-database client database)))
    (ignore-errors (init-views client database))))

#+end_src
* Frontends
Frontends  are basicly APi services that allow external stuff to interact with this system.
** asdf

** http-api

#+begin_src lisp :tangle ./source/frontends/http-api.lisp :result none :comments both
(in-package :star.frontends.http-api)
(defvar *app* (make-instance 'ningle:app))
#+end_src

*** Couchdb client pool
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(in-package :star.frontends.http-api)
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") 5984 :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME")))))
                                    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src
*** STRT Authentication

*** TODO design map api
*** OKAY Submit documents
This route take input documents and inserts them into the rabbitmq =new-documents= queue.


#+begin_src lisp :tangle ./source/frontends/http-api.lisp :comments link
(setf (ningle:route *app* "/new/document/:dtype" :method :post)
      #'(lambda (params)

          (let ((dtype  (cdr (assoc :dtype params :test #'string=)))
                (doc (car (car (lack.request:request-body-parameters (ningle:context :request))))))

            (star.rabbit:emit-document  "new-documents" "documents"  (format nil "documents.new.~a" dtype) doc  :properties (list (list :headers `("dtype" . ,dtype))))
             (format nil "documents.new.~a" dtype))))




#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (PARAMS)) {1001E4405B}>


#+begin_src http :comments none
POST http://0.0.0.0:5000/new/document/person

{"_id":"01HVPX96E8B1FWQCSRFE07Z07R","dataset":"","dtype":"","sources":null,"version":"0.7.1","dateUpdated":1713387117,"dateAdded":1713387117,"fname":"Klaus","mname":"","lname":"Shwabb","bio":"","dob":"","race":"","region":"","misc":null,"etype":"","eid":""}
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Thu, 18 Apr 2024 01:50:21 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: documents.new.person
*** TODO Get Documents

#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(setf (ningle:route *app* "/document/:id" :method :get)
      #'(lambda (params)

          (let ((document-id  (cdr (assoc :id params :test #'string=))))

            (anypool:with-connection (client *couchdb-pool*)
              (cl-couch:get-document client "starintel" document-id)))))
#+end_src

**** example usage
#+begin_src http
GET 127.0.0.1:5000/document/01HVQ6STFR8TA2G6QC5M9EQJQ4
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Fri, 19 Apr 2024 02:11:28 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: {"_id":"01HVQ6STFR8TA2G6QC5M9EQJQ4","_rev":"1-f2c89cf0ec0edd4bce904a91e524da9e","dataset":"starintel","dtype":"person","sources":null,"version":"0.7.1","dateUpdated":1713397099,"dateAdded":1713397099,"fname":"john","mname":"","lname":"doe","bio":"","dob":"","race":"","region":"","misc":null,"etype":"","eid":""}

*** Start webapp
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :comments link
                                        ;(couchdb-middleware *app*)
(defun start-http-api ()
  (clack:clackup *app* :address star:*http-api-address* :port star:*http-api-port*))
#+end_src

#+RESULTS:
: #S(CLACK.HANDLER::HANDLER
:    :SERVER :HUNCHENTOOT
:    :SWANK-PORT NIL
:    :ACCEPTOR #<BORDEAUX-THREADS-2:THREAD "clack-handler-hunchentoot" {10051142F3}>)


* Main Entry
** Cli arg parsing
i opt to use clingon for cli arg parsing.[fn:2]
#+begin_src lisp :tangle ./source/main.lisp :results none :coments link
(in-package :starintel-gserver)
(defun server/options ()
  (list
   (clingon:make-option
    :string
    :description "Path to init file"
    :short-name #\i
    :long-name "init"
    :initial-value "./init.lisp"
    :env-vars '("STAR_SERVER_INIT_FILE")
    :key :init-value)
   (clingon:make-option
    :boolean
    :description "Enable Remote debugging"
    :short-name #\d
    :long-name "debugger"
    :key :debugger)))


#+end_src
** Server command handler
#+begin_src lisp :tangle ./source/main.lisp :results none :comments link

(defun server/handler (cmd)
  (let ((debugger (clingon:getopt cmd :debugger))
        (init-file (clingon:getopt cmd :init-value)))
    (when debugger
      (slynk:create-server :port 50006 :dont-close t))
    (load init-file :if-does-not-exist :create)
    (sento-user::start-actors)


    (sento-user::start-actors)
    (star.frontends.http-api::start-http-api)
    (star.rabbit:start-rabbit-document-thread :host *rabbit-address* :port *rabbit-port*)))

(defun server/command ()
  "A command to greet someone"
  (clingon:make-command
   :name "start"
   :description "start the server"
   :version "0.1.0"
   :authors '("nsaspy <nsaspy@airmail.cc>")
   :license "GPL v3"
   :options (server/options)
   :handler #'server/handler))


(defun main ()
  (clingon:run (server/command))
  (loop do (sleep 3)))
#+end_src

* Tasks
All tasks can have a very general headline, but the NAME must be topic.possibpe-sub-topic.thing scheme.
This section is for [[https://github.com/TxGVNN/project-tasks][project-tasks]].

#+Name:  open.rabbitmq
#+begin_src shell :async :results none
xdg-open http://127.0.0.1:15672/#/
#+end_src

#+Name: open couchdb
#+begin_src shell :async :results none
xdg-open http://127.0.0.1:5984/_utils
#+end_src



** Updates
#+Name: update.flake
#+begin_src shell :async :results output replace
nix flake update
direnv reload .
#+end_src

#+RESULTS: update.flake

#+RESULTS: Update flake
** Docker
*** Run a rabbitmq instance
#+Name: docker.run.rabbitmq
#+begin_src shell :async :results output replace :tangle start.sh
docker run -d -p 5672:5672 -p 15672:15672 -e RABBITMQ_USER=user -e RABBITMQ_PASS=password   rabbitmq:3.13.1-management
#+end_src

#+RESULTS: docker.run.rabbitmq
: 136e9a2898d2fd0d89d9d86ab88e67edeeb8167f2e979b154105256bd2a3726b

#+RESULTS: Start Rabbitmq

*** Kill Rabbitmq
#+Name: docker.kill.rabbitmq
#+begin_src shell :async :results output replace
docker kill rabbitmq_org_dev
#+end_src

#+RESULTS: docker.kill.rabbitmq
: rabbitmq_org_dev


*** List Docker PS
#+Name: docker.ps
#+begin_src shell :async :results output replace
docker ps
#+end_src
** Build
#+Name: build.server
#+begin_src sh :async :results output replace
make build
#+end_src

#+RESULTS: build.server
: b3bc5811a0bf8b118f78669449185d14

* Footnotes
[fn:2] https://github.com/dnaeon/clingon

[fn:1] https://gist.github.com/dnaeon/3a3f86dea1096db5a9231d1f56a565e2
