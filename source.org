#+title: Source
#+STARTUP: show2levels

* Ideas
The main idea of this project is to have a single, closed source api interface that will be the SINGLE source for starintel data

** allow it to be extended
Using common vars/hooks whatever to establish a config that can be updated as i age this system out when EOL.



* Packaging

Given the org-mode file

** Makefile
#+begin_src makefile :tangle Makefile :comments link
##
# Starintel Gserver
#
# @file
# @version 0.1

LISP ?= sbcl

all: test

run:
	$(LISP) --load run.lisp

build:
	$(LISP)	--non-interactive \
		--load source/starintel-gserver.asd \
		--eval '(ql:quickload :starintel-gserver)' \
		--eval "(sb-ext:save-lisp-and-die \"star-server\" :toplevel 'starintel-gserver::main :executable t :compression t)"
install:
	cp star-server /usr/local/bin

clean:
	rm -f ./star-server
#+end_src

** Nix

#+begin_src nix :tangle flake.nix :comments link
{
  description = "Starintel API server that routes the data through msg queues.";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }:
    let
      pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in
    {
      devShell.x86_64-linux =
        pkgs.mkShell {
          buildInputs = with pkgs; [
            pkg-config
            sbcl
            openssl
            rabbitmq-c
            libffi
          ];
          shellHook = ''
            export LD_LIBRARY_PATH=${pkgs.lib.makeLibraryPath([pkgs.openssl pkgs.rabbitmq-c pkgs.libffi])}
          '';
        };
    };
}

#+end_src

Here is
#+begin_src sh
use flake
# When we run make in prod it will gen defaults
# Debug is just for testing
export BUILD_MODE="DEV"
use flake
export COUCHDB_HOST="127.0.0.1"
export COUCHDB_PORT=5984
export COUCHDB_SCHEME="http"
export COUCHDB_USER="admin"
export COUCHDB_PASSWORD="password"
export COUCHDB_DATABASE="starintel"

#+end_src

#+RESULTS:
: CONTAINER ID   IMAGE                             COMMAND                  CREATED        STATUS      PORTS                                                                                                      NAMES
: d421e7dea3a1   zhaowde/rotating-tor-http-proxy   "/bin/sh -c /start.sh"   3 months ago   Up 8 days   3128/tcp, 0.0.0.0:1444->1444/tcp, :::1444->1444/tcp, 4444/tcp, 0.0.0.0:3128->3218/tcp, :::3128->3218/tcp   docker-rotating-tor-1

** Lisp stuff
*** ASDF
Here is the system def for it.
#+begin_src lisp :tangle source/starintel-gserver.asd :comments link
(asdf:defsystem :starintel-gserver
  :version      "0.1.0"
  :description  "hackable/moddable starintel acess api."
  :author       "nsaspy@airmail.cc"
  :license      "GPL v3"
  :serial t
  :build-operation program-op
  :build-pathname "foobar-command" ;; shell name
  :entry-point "foobar::start-foobar" ;; thunk
  :components   (
                 (:file "package")
                 (:file "gserver-settings" :depends-on ("package"))
                 (:file "actors" :depends-on ("gserver-settings"))
                 (:file "rabbit" :depends-on ("actors" "gserver-settings"))
                 (:file "frontends/http-api" :depends-on ("gserver-settings"))
                 (:file "main" :depends-on ("actors" "rabbit" "package" "gserver-settings" "frontends/http-api")))

  :depends-on   (#:starintel #:cl-couch #:serapeum  #:alexandria #:cl-rabbit #:sento #:babel #:cl-json :uuid #:anypool
                             #:clack #:ningle #:hunchentoot #:clingon #:slynk))
 #+end_src
*** Namespace setup
I prefer to have my namespace done in a somewhat hierarchical style.

So lets say you want to make a http frontend api, there is going to be the namespace for it:
- star.frontends.http

And a database namespace would be:
- star.database.<database-type-or-name>


#+begin_src lisp :tangle ./source/frontends/package.lisp :results none :comments link
(uiop:define-package   :star.frontend.http-api
  (:nicknames :frontend.http-api)
  (:use       :cl)
  (:documentation "doc"))
#+end_src

gserver namespace, general top level.

#+begin_src lisp :tangle ./source/package.lisp :comments link
(uiop:define-package   :starintel-gserver
  (:nicknames :star)
  (:use       :cl)
  (:export
   #:init-db
   #:*rabbit-password*
   #:*rabbit-user*
   #:*rabbit-port*
   #:*rabbit-address*
   #:*http-scheme*
   #:*http-key-file*
   #:*http-cert-file*
   #:*http-api-base-path*
   #:*http-api-port*
   #:*http-api-address*))
#+end_src

#+RESULTS:
: #<PACKAGE "STARINTEL-GSERVER">

#+begin_src lisp :tangle ./source/package.lisp :results none :comments link
(uiop:define-package   :starintel-gserver.rabbit
  (:nicknames :star.rabbit)
  (:use       :cl)
  (:documentation "Rabitmq namespace")
  (:export
   #:start-rabbit-document-thread
   #:with-rabbit-send
   #:with-rabbit-recv
   #:emit-document))
#+end_src

#+begin_src lisp :tangle ./source/package.lisp :results none :comments link
(uiop:define-package   :starintel-gserver-http-api
  (:nicknames :star.frontends.http-api)
  (:use       :cl)
  (:documentation "doc"))
#+end_src
** Docker
#+begin_src Dockerfile :tangle ./Dockerfile :comments none
FROM fukamachi/sbcl:latest as build
# Install required packages
RUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt set -x; \
    apt-get update && \
    apt-get install -y \
    make \
    libffi-dev \
    pkg-config \
    librabbitmq-dev \
    build-essential

# Create a user and set up working directory
RUN ros setup

# Copy dependencies
COPY . /root/

# Set up symbolic links using ln
RUN ln -s /root/deps/ /root/common-lisp
WORKDIR /root/
RUN make build
RUN make install
FROM build as star-router
ENV BUILD_MODE="DEV" \
    COUCHDB_HOST="127.0.0.1" \
    COUCHDB_PORT=5984 \
    COUCHDB_SCHEME="http" \
    COUCHDB_USER="admin" \
    COUCHDB_PASSWORD="password" \
    COUCHDB_DATABASE="starintel" \
    HTTP_API_LISTEN_ADDRESS="localhost" \
    RABBITMQ_HOST="rabbitmq" \
    RABBITMQ_PORT=5672
# Expose port 5000
EXPOSE 5000

# Entrypoint to start the server
ENTRYPOINT ./star-server
CMD [./star-server]
#+end_src
** TODO Kali/parrot
#+Name: Install docker
#+begin_src shell :async :results output replace :tangle parrot_kali.sh :comments link
install_docker() {
    sudo apt update
    sudo apt install -y apt-transport-https ca-certificates curl software-properties-common
    curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt update
    sudo apt install -y docker-ce docker-ce-cli containerd.io
    sudo apt install -y docker-compose
    sudo usermod -aG docker $USER

}


install_docker

#+end_src

* Settings
#+begin_src lisp :tangle ./source/gserver-settings.lisp :results none :comments link
(in-package :star)
(defparameter *couchdb-host* "127.0.0.1" "The Couchdb host to use.")
(defparameter *couchdb-port* 5984 "The Couchdb port to use.")
(defparameter *couchdb-default-database* "starintel" "the default database name to use.")
(defparameter *couchdb-target-database* "starintel-targets" "the database to be used for target data.")
#+end_src
** Frontends
*** Http Settings
This section contains only settings related to http frontend

**** Listen Address

#+begin_src lisp :tangle ./source/gserver-settings.lisp :comments link
(defparameter *http-api-address* (or (uiop:getenv "HTTP_API_LISTEN_ADDRESS") "localhost") "the listen address")
(defparameter *http-api-port* 5000  "the port the api server listen on")
(defparameter *http-api-base-path* "/api" "the base url to use for the api endpoint")
(defparameter *http-cert-file* nil "path to the http api cert providing https")
(defparameter *http-key-file* nil "path to the http cert providing https")
(defparameter *http-scheme* 'http "use https or not.")
#+end_src
** Rabbit mq settings
*** Authentication
#+begin_src lisp :tangle ./source/gserver-settings.lisp :comments link
(defparameter *rabbit-address* (or (uiop:getenv "RABBITMQ_ADDRESS") "localhost") "The address rabbitmq is running on.")
(defparameter *rabbit-port* 5672 "The port that rabbitmq is listening on.")
(defparameter *rabbit-user* "guest" "the username for rabbimq")
(defparameter *rabbit-password* "guest" "the password for the rabbitmq user.")

(eval-when (:execute)
  )
#+end_src

#+RESULTS:
: *RABBIT-PASSWORD*


* Actors

** Actor system setup
The sen to package expects us to be in the sento user package.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(in-package :sento-user)
(defparameter *sys* nil "the main actor system")
(defun start-actor-system ()
  (setf *sys* (make-actor-system))
)
 #+end_src

** Eventing

Sento supports events but I can only use a symbol or a simple string. it supports matching by class types too.

This allows actors to filter out messages by topic.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defclass message-event ()
  ((topic :initarg :topic :initform (error "Topic for event stream is required.") :reader message-topic)
   (data :initarg :data :type string :initform "" :reader message-data))
  (:documentation "A basic class that holds message event topic and data"))
#+end_src

The interface for matching topics is ~topic-match-p~.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defgeneric topic-match-p (msg topic)
  (:documentation "generic interface that matches if a msg matches the subbed topic."))

(defmethod topic-match-p ((msg message-event) topic)
  "Return T if topic matches msg's topic"
  (string= topic (string-downcase (message-topic msg))))


(defun new-event (&key topic data (eventstream *sys*))
  "Create an publish a new message-event.
    This is a simple wrapper around the publish from sento."
  (publish eventstream (make-instance 'message-event :topic topic :data data)))


(defmacro with-topics ((&key msg topics) &body body)
  "A macro that will check if MSG topic "
  `(loop for topic in ,topics

         if (topic-match-p ,msg topic)
           do (progn ,@body)))
#+end_src

Here is a simple example of an actor that works with person objects.
#+begin_src lisp
(ac:actor-of *sys* :name "personator"
                   :init (lambda (self)
                           (ev:subscribe self self 'message-event))
                   :receive (lambda (msg)
                              (with-topics (:msg msg :topics '("New-Person"))
                                (format nil "~a" (starintel:doc-id msg)))))

#+end_src
** Couchdb
*** Client Pooling
Couchdb is the main database I have used for many projects, I am using [[https://github.com/lost-rob0t/cl-couch][cl-couch]] for the database client. It doesnt use async so I need to setup a resource pools, for that I use anypool.


#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") 5984 :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME")))))
                                    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src

start--pool-monitoring is used for checking the total active count from the couchdb client pool.
it is only used internally for debugging.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defvar *my-thread* nil)

(defun start--pool-monitoring ()
  (setf *my-thread*
        (bt:make-thread
         (lambda ()
           (loop
             do (progn (format t "Active count: ~a, Idle count: ~a~%"
                               (anypool:pool-active-count *couchdb-pool*)
                               (anypool:pool-idle-count *couchdb-pool*))
                       (force-output)
                       (sleep 1))
             finally (bt:thread-yield))))))

(defun stop--pool-monitoring ()
  (when *my-thread*
    (bt:destroy-thread *my-thread*)
    (setf *my-thread* nil)))

#+end_src

*** couchdb-insert actors
This actor will insert documents into couchdb.

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-inserts* nil)
(defun start-couchdb-inserts ()
  (setf *couchdb-inserts* (ac:actor-of *sys*
                                              :name "*couchdb-inserts*"
                                              :receive (lambda (msg)
                                                         (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
                                                               (pool *couchdb-pool*))

                                                           (with-context (*sys* :pinned)
                                                             (task-start
                                                              (lambda ()
                                                                (anypool:with-connection (client pool)
                                                                  (cl-couch:create-document client destination-db (cdr msg) :batch "normal"))))))))))
#+end_src
*** couchdb-get actor
This actor is to be used by other actors wishing to interact with the couchdb database.
The message to be sent MUST be ~(cons sender data)~.
#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defparameter *couchdb-gets* nil "The Couchdb actor responsible for handling document gets.")

(defun start-couchdb-gets ()
  (setf *couchdb-gets* (ac:actor-of *sys* :name "*couchdb-gets*"
                                          :receive (lambda (msg)
                                                     (let ((pool *couchdb-pool*)
                                                           (db (uiop:getenv "COUCHDB_DATABASE")))
                                                       (with-context (*sys*)
                                                         (anypool:with-connection (client pool)
                                                           (task-async (lambda ()
                                                                         (handler-case
                                                                             (cl-couch:get-document client db (car msg))
                                                                           (dex:http-request-not-found (e) nil)
                                                                           (dex:http-request-unauthorized (e) nil)))
                                                                       :on-complete-fun (lambda (doc)
                                                                                          (reply doc (cdr msg)))))))))))

#+end_src

*** TODO finish bulk insert actor

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
;; (defparameter *couchdb-bulk-insert* (ac:actor-of *sys*
;;                                                  :name "*couchdb-bulk-insert*"
;;                                                  :receive (lambda (msg)
;;                                                             (let ((destination-db (uiop:getenv "COUCHDB_DATABASE"))
;;                                                                   (pool *couchdb-pool*))
;;                                                               (anypool:with-connection (client pool)
;;                                                                 (cl-couch:bulk-create-documents client destination-db msg :batch "normal"))))))



#+end_src


#+end_src
** IDEA Document Handler
#+begin_src lisp
(defun start-document-handler-actor ()
  (defparameter *document-handler* (ac:actor-of *sys*)))


#+end_src
** TODO Create Target scheduling actor
It will be an actor that kicks off recurring jobs, will require spec change to include "recurring" field.
** actor entry point

#+begin_src lisp :tangle ./source/actors.lisp :results none :comments link
(defun start-actors ()
  (start-actor-system)
  (start-couchdb-inserts))
#+end_src

In order to compile the actor system must be stop

* RabbitMQ

** Macro Wrappers
The [[https://github.com/lokedhs/cl-rabbit][cl-rabbit]] lib is a bit lower level then I want to work with so I will create a basic macros to make the interface nicer

The newer sento benchmarks are showing its VERY performent now, so we will actually just create a agent, then use the sento actor system.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(in-package :star.rabbit)

(defmacro with-rabbit-recv ((queue-name exchange-name exchange-type routing-key &key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)
         (cl-rabbit:exchange-declare conn 1 ,exchange-name ,exchange-type)

         (cl-rabbit:queue-declare conn 1 :queue ,queue-name :durable ,durable :auto-delete ,auto-delete :exclusive ,exclusive)
         (cl-rabbit:queue-bind conn 1 :queue ,queue-name :exchange ,exchange-name :routing-key ,routing-key)

         (cl-rabbit:basic-consume conn 1 ,queue-name)
         (loop
           for msg = (cl-rabbit:envelope/message (cl-rabbit:consume-message conn))
           do ,@body)))))

(defmacro with-rabbit-send ((queue-name exchange-name exchange-type routing-key &key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*) (vhost "/") (durable nil) (exclusive nil) (auto-delete nil)) &body body)
  `(cl-rabbit:with-connection (conn)
     (let ((socket (cl-rabbit:tcp-socket-new conn)))
       (cl-rabbit:socket-open socket ,host ,port)
       (when (and ,username ,password)
         (cl-rabbit:login-sasl-plain conn ,vhost ,username ,password))
       (cl-rabbit:with-channel (conn 1)

         ,@body))))

(defun emit-document (queue-name exchange routing-key body &key (properties nil)
                                                             (immediate nil)
                                                             (mandatory nil)
                                                             (port star:*rabbit-port*)
                                                             (host star:*rabbit-address*)
                                                             (username star:*rabbit-user*)
                                                             (password star:*rabbit-password*)
                                                             (vhost "/"))
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket host port)
      (when (and username password)
        (cl-rabbit:login-sasl-plain conn vhost username password))
      (cl-rabbit:with-channel (conn 1)

        (cl-rabbit:queue-bind conn 1 :queue queue-name :exchange exchange :routing-key routing-key)
        (cl-rabbit:basic-publish conn 1 :routing-key routing-key :exchange exchange :mandatory mandatory :immediate immediate :properties properties :body body)))))
#+end_src
** Handle New Document consumers

Take a rabbimq message and parse it.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun message->string (msg &key (encoding :utf-8))
  "take a rabbitmq message and return the boddy as a string"
  (babel:octets-to-string (cl-rabbit:message/body msg) :encoding encoding))

                                        ;TODO
(defun message->object (msg)
  "Tale a rabbbitmq message and return a object. The object that will be returned depends on the message property 'dtype`.")

(defun handle-new-document (msg)
  "Handles any new incoming documents and sends it to the appropriate actors."
  (let* ((props (cl-rabbit:message/properties msg))
         (headers (assoc :HEADERS props :test #'equal))
         (dtype (when headers (cdr (assoc "dtype" (cdr headers) :test #'equal))))
         (body (message->string msg)))
    (cons dtype body)))
#+end_src

Start the rabbit new document monitoring thread.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun start-rabbit-document-thread (&key (port star:*rabbit-port*) (host star:*rabbit-address*) (username star:*rabbit-user*) (password star:*rabbit-password*))
  (loop for i from 0 to 4
        do (bt:make-thread
            (lambda ()
              (with-rabbit-recv ("injest" "documents" "topic" "documents.new.*")
                (let (
                      (data (handle-new-document msg)))
                  (sento-user::ask sento-user::*couchdb-inserts* data))))
            ;; (sento-user::publish sento-user::*sys* (sento-user::new-event :topic (string-downcase (car data)) :data (cdr data)))


            :name "*new-documents*")))
#+end_src
** quick test functions

These functions are for quick debugging of the rabbitmq.

#+begin_src lisp :tangle ./source/rabbit.lisp :results none
(defun test-make-doc ()

  (with-output-to-string (str) (cl-json:encode-json (starintel:set-meta (make-instance  'starintel:person :id (uuid:make-v4-uuid) :lname "doe" :fname "john") "starintel") str)))

(defun test-send ()
  (cl-rabbit:with-connection (conn)
    (let ((socket (cl-rabbit:tcp-socket-new conn)))
      (cl-rabbit:socket-open socket "localhost" 5672)
      (cl-rabbit:login-sasl-plain conn "/" "guest" "guest")
      (cl-rabbit:with-channel (conn 1)
        (cl-rabbit:basic-publish conn 1
                                 :exchange "documents"
                                 :routing-key "documents.new.Person"
                                 :body (test-make-doc)
                                 :properties '((:headers . (("dtype"  . "Person")))))))))
#+end_src

* Databases
** Couchdb
#+begin_src lisp :tangle ./source/init.lisp :results none
(in-package :starintel-gserver)


(defun init-db ()
  "Create the database, and all map-reduce views with it."
  (let* ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") (parse-integer (or (uiop:getenv "COUCHDB_PORT") 5984)) :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME"))))
         (database (or (uiop:getenv "COUCHDB_DATABASE") "starintel")))
    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
    (handler-case (cl-couch:get-database client database)
      (dexador:http-request-not-found () (cl-couch:create-database client database)))))

#+end_src
* Frontends
Frontends  are basicly APi services that allow external stuff to interact with this system.
** asdf

** http-api
*** Couchdb client pool
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(defparameter *couchdb-pool*
  (anypool:make-pool :name "couchdb-connections"
                     :connector (lambda ()
                                  (let ((client (cl-couch:new-couchdb (uiop:getenv "COUCHDB_HOST") 5984 :scheme (string-downcase (uiop:getenv "COUCHDB_SCHEME")))))
                                    (cl-couch:password-auth client (uiop:getenv "COUCHDB_USER") (uiop:getenv "COUCHDB_PASSWORD"))
                                    client))

                     :disconnector (lambda (obj)
                                     (setf (cl-couch:couchdb-headers obj) nil))
                     :max-open-count 20))
#+end_src
*** STRT Authentication

*** TODO design map api
*** OKAY Submit documents
This route take input documents and inserts them into the rabbitmq =new-documents= queue.


#+begin_src lisp :tangle ./source/frontends/http-api.lisp :comments link
(setf (ningle:route *app* "/new/document/:dtype" :method :post)
      #'(lambda (params)

          (let ((dtype  (cdr (assoc :dtype params :test #'string=)))
                (doc (car (car (lack.request:request-body-parameters (ningle:context :request))))))

            (star.rabbit:emit-document  "new-documents" "documents"  (format nil "documents.new.~a" dtype) doc  :properties (list (list :headers `("dtype" . ,dtype))))
             (format nil "documents.new.~a" dtype))))




#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (PARAMS)) {1001E4405B}>


#+begin_src http :comments none
POST http://0.0.0.0:5000/new/document/person

{"_id":"01HVPX96E8B1FWQCSRFE07Z07R","dataset":"","dtype":"","sources":null,"version":"0.7.1","dateUpdated":1713387117,"dateAdded":1713387117,"fname":"Klaus","mname":"","lname":"Shwabb","bio":"","dob":"","race":"","region":"","misc":null,"etype":"","eid":""}
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Thu, 18 Apr 2024 01:50:21 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: documents.new.person
*** TODO Get Documents

#+begin_src lisp :tangle ./source/frontends/http-api.lisp :results none :comments link
(setf (ningle:route *app* "/document/:id" :method :get)
      #'(lambda (params)

          (let ((document-id  (cdr (assoc :id params :test #'string=))))

            (anypool:with-connection (client *couchdb-pool*)
              (cl-couch:get-document client "starintel" document-id)))))
#+end_src

**** example usage
#+begin_src http
GET 127.0.0.1:5000/document/01HVQ6STFR8TA2G6QC5M9EQJQ4
#+end_src

#+RESULTS:
: HTTP/1.1 200 OK
: Date: Fri, 19 Apr 2024 02:11:28 GMT
: Server: Hunchentoot 1.3.0
: Transfer-Encoding: chunked
: Content-Type: text/html; charset=utf-8
:
: {"_id":"01HVQ6STFR8TA2G6QC5M9EQJQ4","_rev":"1-f2c89cf0ec0edd4bce904a91e524da9e","dataset":"starintel","dtype":"person","sources":null,"version":"0.7.1","dateUpdated":1713397099,"dateAdded":1713397099,"fname":"john","mname":"","lname":"doe","bio":"","dob":"","race":"","region":"","misc":null,"etype":"","eid":""}

*** Start webapp
#+begin_src lisp :tangle ./source/frontends/http-api.lisp :comments link
                                        ;(couchdb-middleware *app*)
(defun start-http-api ()
  (clack:clackup *app* :address star:*http-api-address* :port star:*http-api-port*))
#+end_src

#+RESULTS:
: #S(CLACK.HANDLER::HANDLER
:    :SERVER :HUNCHENTOOT
:    :SWANK-PORT NIL
:    :ACCEPTOR #<BORDEAUX-THREADS-2:THREAD "clack-handler-hunchentoot" {10051142F3}>)


* Main Entry
** Cli arg parsing
i opt to use clingon for cli arg parsing.[fn:2]
#+begin_src lisp :tangle ./source/main.lisp :results none :coments link
(in-package :starintel-gserver)
(defun server/options ()
  (list
   (clingon:make-option
    :string
    :description "Path to init file"
    :short-name #\i
    :long-name "init"
    :initial-value "./init.lisp"
    :env-vars '("STAR_SERVER_INIT_FILE")
    :key :init-value)
   (clingon:make-option
    :boolean
    :description "Enable Remote debugging"
    :short-name #\d
    :long-name "debugger"
    :key :debugger)))


#+end_src
** Server command handler
#+begin_src lisp :tangle ./source/main.lisp :results none :comments link

(defun server/handler (cmd)
  (let ((debugger (clingon:getopt cmd :debugger))
        (init-file (clingon:getopt cmd :init-value)))
    (when debugger
      (slynk:create-server :port 50006 :dont-close t))
    (load init-file :if-does-not-exist :create)
    (sento-user::start-actors)


    (sento-user::start-actors)
    (star.frontends.http-api::start-http-api)
    (star.rabbit:start-rabbit-document-thread :host *rabbit-address* :port *rabbit-port*)))

(defun server/command ()
  "A command to greet someone"
  (clingon:make-command
   :name "start"
   :description "start the server"
   :version "0.1.0"
   :authors '("nsaspy <nsaspy@airmail.cc>")
   :license "GPL v3"
   :options (server/options)
   :handler #'server/handler))


(defun main ()
  (clingon:run (server/command))
  (loop do (sleep 3)))
#+end_src

* Tasks
All tasks can have a very general headline, but the NAME must be topic.possibpe-sub-topic.thing scheme.
This section is for [[https://github.com/TxGVNN/project-tasks][project-tasks]].

#+Name:  open.rabbitmq
#+begin_src shell :async :results none
xdg-open http://127.0.0.1:15672/#/
#+end_src

#+Name: open couchdb
#+begin_src shell :async :results none
xdg-open http://127.0.0.1:5984/_utils
#+end_src



** Updates
#+Name: update.flake
#+begin_src shell :async :results output replace
nix flake update
direnv reload .
#+end_src

#+RESULTS: update.flake

#+RESULTS: Update flake
** Docker
*** Run a rabbitmq instance
#+Name: docker.run.rabbitmq
#+begin_src shell :async :results output replace :tangle start.sh
docker run -d -p 5672:5672 -p 15672:15672 -e RABBITMQ_USER=user -e RABBITMQ_PASS=password   rabbitmq:3.13.1-management
#+end_src

#+RESULTS: docker.run.rabbitmq
: 136e9a2898d2fd0d89d9d86ab88e67edeeb8167f2e979b154105256bd2a3726b

#+RESULTS: Start Rabbitmq

*** Kill Rabbitmq
#+Name: docker.kill.rabbitmq
#+begin_src shell :async :results output replace
docker kill rabbitmq_org_dev
#+end_src

#+RESULTS: docker.kill.rabbitmq
: rabbitmq_org_dev


*** List Docker PS
#+Name: docker.ps
#+begin_src shell :async :results output replace
docker ps
#+end_src
** Build
#+Name: build.server
#+begin_src sh :async :results output replace
make build
#+end_src

#+RESULTS: build.server
: b3bc5811a0bf8b118f78669449185d14

* Footnotes
[fn:2] https://github.com/dnaeon/clingon

[fn:1] https://gist.github.com/dnaeon/3a3f86dea1096db5a9231d1f56a565e2
